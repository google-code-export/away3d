package away3dlite.primitives{	import away3dlite.arcane;	import away3dlite.core.base.*;	import away3dlite.materials.*;		import flash.geom.Vector3D;
	use namespace arcane;	/**	 * Creates a 3D BoundingBox primitive.	 */	public class BoundingBox extends Cube6	{		private var _targetMesh:Mesh;		/**		 * Creates a new <code>BoundingBox</code> object.		 * 		 * @param targetMesh	Mesh target that you want to monitor bounding		 * @param wireColor		border color		 * @param wireAlpha		border alpha		 * @param thickness		border thickness		 * 		 */		public function BoundingBox(targetMesh:Mesh, wireColor:* = null, wireAlpha:Number = 1, thickness:Number = 1)		{			_targetMesh = targetMesh;						super(new QuadWireframeMaterial(wireColor, wireAlpha, thickness), 0, 0, 0);						// bind to target mesh			_targetMesh.useBoundingBox = true;			_targetMesh.onBoundingBoxUpdate = applyBoundingBox;			type = "BoundingBox";			url = "primitive";		}				private function applyBoundingBox(minBounding:Vector3D, maxBounding:Vector3D):void		{			var minX:Number, minY:Number, minZ:Number, maxX:Number, maxY:Number, maxZ:Number;						minX = minBounding.x;			minY = minBounding.y;			minZ = minBounding.z;						maxX = maxBounding.x;			maxY = maxBounding.y;			maxZ = maxBounding.z;						var i:int = 0;			 			_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = maxY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = minZ;						_vertices[int(i++)]  = maxX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;						_vertices[int(i++)]  = minX;			_vertices[int(i++)]  = minY;			_vertices[int(i++)]  = maxZ;		}	}}