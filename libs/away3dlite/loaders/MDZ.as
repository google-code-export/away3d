package away3dlite.loaders{	import away3dlite.animators.MovieMesh;	import away3dlite.animators.MovieMeshContainer3D;	import away3dlite.arcane;	import away3dlite.containers.ObjectContainer3D;	import away3dlite.events.Loader3DEvent;	import away3dlite.events.ParserEvent;	import away3dlite.loaders.AbstractParser;	import away3dlite.loaders.MD2;	import away3dlite.loaders.data.MaterialData;	import away3dlite.loaders.utils.MaterialLibrary;	import away3dlite.materials.BitmapFileMaterial;	import away3dlite.materials.BitmapMaterial;	import away3dlite.materials.ColorMaterial;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.events.Event;	import flash.utils.ByteArray;	import flash.utils.Dictionary;		import mx.graphics.codec.PNGEncoder;		import nochump.util.zip.ZipEntry;	import nochump.util.zip.ZipFile;

	use namespace arcane;		/**	 * File loader for the MDZ file format. (MD2, PNG, MD2, PNG,...) in zip format.	 * @author katopz@sleepydesign.com	 */	public class MDZ extends AbstractParser	{		public var meshes:Vector.<MovieMesh>;		private var _materials:Dictionary;				/** @private */		arcane override function prepareData(data:*):void		{			var i:int = 0;			var _zipFile:ZipFile = new ZipFile(data);			var _entry:ZipEntry;			var _fileType:String;			var _fileName:String;			_materials = new Dictionary(true);			// material			for (i = 0; i < _zipFile.entries.length; i++)			{				_entry = _zipFile.entries[i];				_fileType = _entry.name.slice(_entry.name.indexOf("."));				_fileName = _entry.name.split(_fileType)[0];				if (_fileType == ".png")				{					var _bmpByteArray:ByteArray = _zipFile.getInput(_entry);					_materials[_fileName] = _bmpByteArray;				}			}						// mesh			for (i = 0; i < _zipFile.entries.length; i++)			{				_entry = _zipFile.entries[i];				_fileType = _entry.name.slice(_entry.name.indexOf("."));				_fileName = _entry.name.split(_fileType)[0];				if (_fileType == ".md2")				{					var _md2ByteArray:ByteArray = _zipFile.getInput(_entry);					var _md2:MD2 = new MD2();					_md2.scaling = scaling;					_md2.addOnSuccess(onSuccess);										_md2.material = new BitmapFileMaterial();					_md2.parseGeometry(_md2ByteArray);					BitmapFileMaterial(_md2.material).loadBytes(_materials[_md2.textureName]);				}			}			// gc			_materials = null;		}		private function onSuccess(event:ParserEvent):void		{			var model:MovieMesh = event.result as MovieMesh;			model.bothsides = bothsides;			model.play();			if (!meshes)				meshes = new Vector.<MovieMesh>();			meshes.fixed = false;			meshes.push(model);			meshes.fixed = true;			_container.addChild(model);		}		public var bothsides:Boolean = false;		/**		 * A scaling factor for all geometry in the model. Defaults to 1.		 */		public var scaling:Number = 1;		/**		 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.		 */		public var centerMeshes:Boolean;		/**		 * Creates a new <code>MDZ</code> object.		 */		public function MDZ()		{			_container = new MovieMeshContainer3D();			binary = true;		}	}}