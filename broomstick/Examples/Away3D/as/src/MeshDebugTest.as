package {		[SWF(width="1168", height="700", frameRate="60")]		import away3d.entities.Mesh;	import away3d.containers.View3D;	import away3d.cameras.lenses.PerspectiveLens;	import away3d.cameras.Camera3D;	import away3d.materials.BitmapMaterial;	import away3d.debug.AwayStats;	import away3d.lights.PointLight;	import away3d.primitives.Cube;	import away3d.primitives.Sphere;	import away3d.primitives.WireframePlane;	import away3d.extrusions.LatheExtrude;		import away3d.tools.MeshDebugger;	 	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.geom.Vector3D;	import flash.events.Event;		import flash.utils.setTimeout;	 	public class MeshDebugTest extends MovieClip	{ 		private var _view : View3D;		private var camera:Camera3D;		private var origin:Vector3D = new Vector3D(0,0,0);		private var wave:Number = 0;		private var _light1:PointLight;		private var _light2:PointLight;		private var _meshDebugger:MeshDebugger;				private var _cube:Cube;		private var _sphere:Sphere;		 		public function MeshDebugTest():void		{			addEventListener(Event.ADDED_TO_STAGE, init);		}		 		private function init(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);						initView();			addLights();			populate();			 			this.addEventListener(Event.ENTER_FRAME, handleEnterFrame);		}		 		private function addLights():void		{			_light1 = new PointLight();			_light1.x = -4000;			_light1.y = 6000;			_light1.z = -4000;			_light1.radius = 8000;			_light1.fallOff = 15000;			_light1.color = 0xFF9900; 			_view.scene.addChild(_light1);						_light2 = new PointLight();			_light2.x = 4000;			_light2.y = 2000;			_light2.z = 4000;			_light2.radius = 8000;			_light2.fallOff = 15000;			_light2.color = 0xFFFFFF; 			_view.scene.addChild(_light2);		}				private function initView():void		{			_view = new View3D();			_view.antiAlias = 2;			_view.backgroundColor = 0x333333;			camera = _view.camera;			camera.lens = new PerspectiveLens();			camera.x = 500;			camera.y = 120;			camera.z = 500;			addChild(_view);			addChild(new AwayStats(_view));			 			camera.lens.near = 10;			camera.lens.far = 15000;		}				private function populate() : void		{			var mat:BitmapMaterial = new BitmapMaterial(new BitmapData(256,256, false, 0xFF0000));			mat.lights = [_light1, _light2];						// This cube rotates on enterFrame, we need to let class known something needs an update			// --> see line update in enterFrame			_cube = new Cube(mat, 400, 300, 500);			_cube.y = 200;			_cube.x = -800;			_view.scene.addChild(_cube);						_sphere = new Sphere(mat, 400);			_sphere.y = 200;			_sphere.name = "sphere";			_view.scene.addChild(_sphere);						//2 Lathes with smmoth on and off, to see the diff between vertex normals			var profile:Vector.<Vector3D> = new Vector.<Vector3D>();			profile[0] = new Vector3D(0, 50, 0);			profile[1] = new Vector3D(-100, 0, 0);			profile[2] = new Vector3D(-100, 50, 0);			profile[3] = new Vector3D(-50, 90, 0);			profile[4] = new Vector3D(-120, 130, 0);			profile[5] = new Vector3D(-140, 150, 0);			profile[6] = new Vector3D(-180, 250, 0);			profile[7] = new Vector3D(-170, 400, 0);						// to see the difference of vertexnormals: 2 lathes object with either flat or smoothed surface.			var Lathe1:LatheExtrude = new LatheExtrude(mat, profile, LatheExtrude.Y_AXIS, 1, 40, true, true, true, 30, false);			Lathe1.x = 800;			Lathe1.z = - 450;			Lathe1.y = 200;			Lathe1.smoothSurface = false;			_view.scene.addChild(Lathe1);						var Lathe2:LatheExtrude = new LatheExtrude(mat, profile, LatheExtrude.Y_AXIS, 1, 40, true, true, true, 30, false);			Lathe2.x = 800;			Lathe2.z =  450;			Lathe2.y = 200;			Lathe2.smoothSurface = true;			_view.scene.addChild(Lathe2);						//MeshDebugger						_meshDebugger = new MeshDebugger();			//optional segments length			_meshDebugger.lengthNormals = 200;			_meshDebugger.lengthVertexNormals = 100;			_meshDebugger.lengthTangents = 150;						/*//optional color settings			_meshDebugger.colorNormals = 0xFF0000;			_meshDebugger.colorVertexNormals = 0xFFFFFF;			_meshDebugger.colorTangents = 0x00FF00*/						_meshDebugger.debug(Mesh(_cube), _view.scene, true, true, true);			_meshDebugger.debug(Mesh(_sphere), _view.scene, true, true, true);						_meshDebugger.debug(Mesh(Lathe1), _view.scene, false, true, false);			_meshDebugger.debug(Mesh(Lathe2), _view.scene, false, true, false);									//another way to help you partition visually the space			var wireframePlane:WireframePlane = new WireframePlane(1000, 1000, 10, 10, 0xFFFFFF, 1, WireframePlane.ORIENTATION_XZ);			_view.scene.addChild(wireframePlane);						// in the unlikely event that you would want to change settings while it runs (bad idea for large meshes)			// setTimeout(changeSettingsDelay, 3000);		}				private function changeSettingsDelay() : void		{			//removing the debug feature --> no longer exists			_meshDebugger.removeDebug(_cube);						// to allow toggles for editors without updating or destroying anything			_meshDebugger.hideDebug(_sphere);						// changing all settings runtime is possible, but not recommanded			_meshDebugger.lengthNormals = 70;			_meshDebugger.lengthVertexNormals = 80;			_meshDebugger.lengthTangents = 100;			_meshDebugger.colorNormals = 0xFF0000;			_meshDebugger.colorVertexNormals = 0xFFFFFF;			_meshDebugger.colorTangents = 0x00FF00; 		}		 		private function handleEnterFrame(e : Event) : void		{			_view.camera.position = origin;			_view.camera.rotationY += 1;			_view.camera.moveBackward(2500);						 wave+= .02;			_view.camera.y =  600*Math.sin(wave);			camera.lookAt(origin);						_cube.rotationY-= 2;						//OPTIONAL if an object changes			// the cube in this case, has changed on rotationY, let's ask the MeshDebugger class to update			_meshDebugger.update();			 			_view.render();		}		 	}}