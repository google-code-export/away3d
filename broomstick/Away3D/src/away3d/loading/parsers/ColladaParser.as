package away3d.loading.parsers{	import away3d.animators.data.SkeletonAnimationSequence;	import away3d.animators.skeleton.JointPose;	import away3d.animators.skeleton.Skeleton;	import away3d.animators.skeleton.SkeletonJoint;	import away3d.animators.skeleton.SkeletonPose;	import away3d.arcane;	import away3d.core.base.SkinnedSubGeometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.core.math.Quaternion;	import away3d.entities.Mesh;	import away3d.events.LoaderEvent;	import away3d.events.ResourceEvent;	import away3d.loading.BitmapDataResource;	import away3d.loading.IResource;	import away3d.loading.ResourceManager;	import away3d.materials.BitmapMaterial;	import away3d.materials.ColorMaterial;	import away3d.materials.DefaultMaterialBase;	import away3d.materials.SegmentMaterial;	import away3d.tools.serialize.Serialize;	import away3d.tools.serialize.TraceSerializer;		import flash.display.BitmapData;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Vector3D;	import flash.utils.Dictionary;		import org.ascollada.core.DaeAnimation;	import org.ascollada.core.DaeBlendWeight;	import org.ascollada.core.DaeChannel;	import org.ascollada.core.DaeController;	import org.ascollada.core.DaeDocument;	import org.ascollada.core.DaeGeometry;	import org.ascollada.core.DaeImage;	import org.ascollada.core.DaeInput;	import org.ascollada.core.DaeInstanceController;	import org.ascollada.core.DaeInstanceGeometry;	import org.ascollada.core.DaeNode;	import org.ascollada.core.DaePrimitive;	import org.ascollada.core.DaeSkin;	import org.ascollada.core.DaeSource;	import org.ascollada.core.DaeTransform;	import org.ascollada.fx.DaeBindVertexInput;	import org.ascollada.fx.DaeColor;	import org.ascollada.fx.DaeEffect;	import org.ascollada.fx.DaeInstanceMaterial;	import org.ascollada.fx.DaeLambert;	import org.ascollada.fx.DaeMaterial;	import org.ascollada.fx.DaePhong;
		use namespace arcane;		/**	 * AWDParser provides a parser for the Collada (DAE) data type.	 */	public class ColladaParser extends ParserBase	{		private var _daeDoc : DaeDocument;		private var _mesh : Mesh; // serves as 'root' resource served up from this parser (when not "JOINT" node type)		private var _skeleton : Skeleton;		private var _textureFilenameOverride : String; // TODO, generalize and allow for more than one override				private var _daeParsingState : uint;		private var _bitmapDataResourceRequest : Object; // url -> BitmapDataResource		private var _bitmapDataResourceMaterialInfo : Object; // daeMaterial.id -> Object(imageURI, daeLambert)		private var _materials : Object; // adhoc dict - _daeDoc.materialTargetToSymbol[daeMaterial.id] -> MaterialBase		private var _texCoordSets : Object; // adhoc dict - daeMaterial.id -> daeLambert.diffuse.texture.texcoord		private var _overrideBitmapMaterials : Boolean;				/**		 * Creates a new ColladaParser object.		 * @param uri The url or id of the data or file to be parsed. TODO: to be removed, and errors sent as events to AssetLoader, where uri is available.		 * @param skeleton Skeleton object if animations are being parsed (REQUIRED if skeleton not in same file as animation)		 * @param textureFilenameOverride a single texture to be loaded instead of referenced texture in file. TODO: fix to allow multiple overrides		 */		public function ColladaParser(uri : String, skeleton : Skeleton = null, textureFilenameOverride : String = null)		{			if (skeleton)			{				_skeleton = skeleton;			}			else			{				_skeleton = new Skeleton();			}			_textureFilenameOverride = textureFilenameOverride;			_bitmapDataResourceRequest = new Object();			_bitmapDataResourceMaterialInfo = new Object();			_materials = new Object();			_texCoordSets = new Object();			super(uri, ParserDataFormat.PLAIN_TEXT);			ResourceManager.instance.addEventListener(ResourceEvent.RESOURCE_RETRIEVED, onBitmapResourceRetrieved);			ResourceManager.instance.addEventListener(LoaderEvent.LOAD_ERROR, onBitmapResourceLoadError); 			ResourceManager.instance.addEventListener(LoaderEvent.LOAD_MAP_ERROR, onBitmapResourceLoadMapError);		}				/**		 * Indicates whether or not a given file extension is supported by the parser.		 * @param extension The file extension of a potential file to be parsed.		 * @return Whether or not the given file type is supported.		 */		public static function supportsType(extension : String) : Boolean		{			extension = extension.toLowerCase();			return extension == "dae";		}				/**		 * Tests whether a data block can be parsed by the parser.		 * @param data The data block to potentially be parsed.		 * @return Whether or not the given data is supported.		 */		public static function supportsData(data : *) : Boolean		{			// todo: implement			return false;		}				/**		 * @inheritDoc		 */		override protected function initHandle() : IResource		{			_mesh = new Mesh();						return _mesh;		}				private function filenameFromPath(path:String):String		{			var lastSlashIndex:int = this.uri.lastIndexOf("/");			if (lastSlashIndex == -1)			{				return path;			}			else			{				return path.slice(lastSlashIndex+1);			}		}				/**		 * @inheritDoc		 */		protected override function proceedParsing() : Boolean		{			// _daeParsingState key			// 0:just starting			// 1:parsing dae			// 2:done parsing dae, images requested			// 3:images loaded, finish parsing the rest			// 4:completely done						if (_daeParsingState == 0)			{				// set this to true to override every specified texture with red material instead				_overrideBitmapMaterials = false;								trace("-- [", filenameFromPath(this.uri),"] [1] collada parse requested");				_daeDoc = new DaeDocument();				var xml:XML = new XML(_textData);				_daeDoc.addEventListener(Event.COMPLETE, onParseColladaDocComplete);				_daeDoc.read(xml);								// right order to do things (based on DAE.as from Papervision3D)				// 1. load all "referred to" dae files, if any.  I'll skip this step to start with - hopefully will not need it.				// 2. iterate through DaeMaterial's.  I assume this loads textures and caches references.				// 3. iterate through DaeNode's (recursive). (this brings in geometry and skins)				// 4. iterate through DaeAnimation's (NOT WORKING)								_daeParsingState++; // to 1								return MORE_TO_PARSE;			}			else if ((_daeParsingState == 1) || (_daeParsingState == 2))			{				// collada parse in process				return MORE_TO_PARSE;			}			else if (_daeParsingState == 3)			{				continueColladaInterpret();				return MORE_TO_PARSE;			}			else			{				trace("-- [", filenameFromPath(this.uri),"] [4] parsing done!");				return PARSING_DONE;			}		}				private function notifyGoingToStage3():void		{			trace("-- [", filenameFromPath(this.uri),"] [3] image loads completed (if any).");		}				// The doc has been read in. Now it must be processed.		private function onParseColladaDocComplete(e:Event):void		{			var requestedBitmaps : Boolean;			// begin interpret _daeDoc						// 2. iterate through DaeMaterial's			for each (var daeMaterial:DaeMaterial in _daeDoc.materials)			{				var daeEffect:DaeEffect = _daeDoc.effects[daeMaterial.instance_effect];								if (daeEffect != null)				{					if (daeEffect.shader is DaeLambert)					{						var daeLambert:DaeLambert = daeEffect.shader as DaeLambert;												if (daeLambert.diffuse.texture && daeEffect.surface)						{							if (_overrideBitmapMaterials)							{								createAndCacheColorMaterial(daeMaterial.id, 0xFF0000, daeLambert);							}							else							{								// save texCoord reference for later usage 								_texCoordSets[daeMaterial.id] = daeLambert.diffuse.texture.texcoord;																// figure out which texture to load								var daeImage:DaeImage = _daeDoc.images[daeEffect.surface.init_from];								if (daeImage)								{									var imageURI:String;																		// look for texture override									if (_textureFilenameOverride)									{										imageURI = _textureFilenameOverride;									}									else									{										// TODO: the slice is too special-case										imageURI = this.baseUri + daeImage.init_from.slice(2, daeImage.init_from.length);									}																		// has this image already been requested? 									if (_bitmapDataResourceRequest[imageURI] == null)									{										// no, so request it										_bitmapDataResourceRequest[imageURI] = new Object();										trace("-- [", filenameFromPath(this.uri),"] Requesting bitmap", imageURI);										_bitmapDataResourceRequest[imageURI].res = ResourceManager.instance.getResource(imageURI) as BitmapDataResource;										_bitmapDataResourceRequest[imageURI].heardBack = false;																				registerBitmapMaterialWaitingForBitmapData(daeMaterial.id, imageURI, daeLambert);																				requestedBitmaps = true;									}									else									{										// yes, we requested this BitmapData already										if (_bitmapDataResourceRequest[imageURI].heardBack)										{											// and, in fact, we already heard back (and in this case, since its not in the _bitmapDataCache, it doesn't exist											// assign a red material											createAndCacheColorMaterial(daeMaterial.id, 0xFF0000, daeLambert);										}										else										{											registerBitmapMaterialWaitingForBitmapData(daeMaterial.id, imageURI, daeLambert);										}									}								}							}						}						else if (daeLambert.diffuse.color)						{							if (daeEffect.wireframe)							{								createAndCacheWireframeMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}							else							{								createAndCacheColorMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}						}					}				}			}			trace("-- [", filenameFromPath(this.uri),"] [2] collada parse completed. image loads requested (if any).");			_daeParsingState++; // to 2						if (_overrideBitmapMaterials || !requestedBitmaps)			{				// skip wait for bitmaps to load - because we don't have any to wait for				notifyGoingToStage3();				_daeParsingState++; // to 3			}			else			{				// !!! see onBitmapResourceRetrieved() for rest of parse !!!			}		}				private function heardBackForAllBitmapLoads():Boolean		{			if (_daeParsingState == 2)			{				for each (var obj:* in _bitmapDataResourceRequest)				{					if (!obj.heardBack)					{						return false;					}				}								return true;			}			else			{				return false;			}		}				private function registerBitmapMaterialWaitingForBitmapData(daeMaterialID:String, imageURI:String, daeLambert:DaeLambert):void		{			// many materials may request the same bitmap. this allows them to be loaded			if (_bitmapDataResourceMaterialInfo[daeMaterialID] == null)			{				_bitmapDataResourceMaterialInfo[daeMaterialID] = new Object();				_bitmapDataResourceMaterialInfo[daeMaterialID].imageURI = imageURI;				_bitmapDataResourceMaterialInfo[daeMaterialID].daeLambert = daeLambert;			}			else			{				trace("-- [", filenameFromPath(this.uri),"] material id", daeMaterialID, "already requested?!?!?!?!");			}		}				private function processWaitingBitmapMaterials(imageURI:String, bitmapData:BitmapData):void		{			var deleteMe:Vector.<String> = new Vector.<String>();			for (var daeMaterialID:String in _bitmapDataResourceMaterialInfo)			{				var obj:Object = _bitmapDataResourceMaterialInfo[daeMaterialID];				if (obj.imageURI == imageURI)				{					if (bitmapData != null)					{						createAndCacheBitmapMaterial(daeMaterialID, bitmapData, obj.daeLambert);					}					else					{						createAndCacheColorMaterial(daeMaterialID, 0xFF0000, obj.daeLambert);					}										deleteMe.push(daeMaterialID);				}			}						for each (var daeMaterialIDToDelete:String in deleteMe)			{				delete _bitmapDataResourceMaterialInfo[daeMaterialIDToDelete];								}		}				private function createAndCacheColorMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			var material:ColorMaterial = new ColorMaterial(color);			material.gloss = 20;			material.specular = 1.5;			material.ambientColor = 0x505060;			applyMaterialParams(material, daeLambert);			_materials[daeMaterialID] = material;		}				private function createAndCacheBitmapMaterial(daeMaterialID:String, bitmapData:BitmapData, daeLambert:DaeLambert):void		{			var material:BitmapMaterial = new BitmapMaterial(bitmapData);			applyMaterialParams(material, daeLambert);			_materials[daeMaterialID] = material;		}				private function createAndCacheWireframeMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			var material:SegmentMaterial = new SegmentMaterial(); // TODO: figure out how to apply lambert.diffuse.color to the wireframe material			_materials[daeMaterialID] = material;		}				private function onBitmapResourceRetrieved(event:ResourceEvent):Boolean		{			var loaded:Boolean;			var loaded_bdr:BitmapDataResource = event.resource as BitmapDataResource;						if (loaded_bdr != null)			{				var request:Object = _bitmapDataResourceRequest[event.uri];				if (request != null)				{					var bdr:BitmapDataResource = request.res;					if (bdr == loaded_bdr)					{						trace("-- [", filenameFromPath(this.uri),"] Loaded bitmap", event.uri);												// store in the bitmapDataCache						request.heardBack = true;						loaded = true;												// find all materials that were waiting for this BitmapData						processWaitingBitmapMaterials(event.uri, bdr.bitmapData);												// have we heard back from all bitmap loads?						// if so, transition to next loading state.						if (heardBackForAllBitmapLoads())						{							notifyGoingToStage3();							_daeParsingState++; // to 3						}					}				}			}						return loaded;		}				private function onBitmapResourceLoadError(event:LoaderEvent):void		{			trace("-- [", filenameFromPath(this.uri),"] LOAD ERROR:", event.url, "not found!");		}				private function onBitmapResourceLoadMapError(event:LoaderEvent):void		{			var request:Object = _bitmapDataResourceRequest[event.url];			if (request != null)			{				var bdr:BitmapDataResource = request.res;								if (bdr != null)				{					trace("-- [", filenameFromPath(this.uri),"] ERROR: Failed to load bitmap", event.url);					request.heardBack = true;										// find all materials that were waiting for this BitmapData					processWaitingBitmapMaterials(event.url, null);										// have we heard back from all bitmap loads?					// if so, transition to next loading state.					if (heardBackForAllBitmapLoads())					{						notifyGoingToStage3();						_daeParsingState++; // to 3					}				}			}		}				private function continueColladaInterpret():void		{			// 3. iterate through DaeNode's (recursive, buildNode calls itself).			if (_daeDoc.scene != null)			{				for each (var daeNode:DaeNode in _daeDoc.scene.nodes)				{					if (daeNode.type == "JOINT")					{						var skeletonDefaultPose:SkeletonPose = new SkeletonPose();						skeletonAndDefaultPoseFromNode(_skeleton, skeletonDefaultPose, daeNode, -1);					}					else					{						meshFromNode(_mesh, daeNode);					}				}			}						// 4. iterate through DaeAnimation's			if (_daeDoc.animations != null)			{				var skeletonPoses:Dictionary;								for each (var daeAnimation:DaeAnimation in _daeDoc.animations)				{					if (skeletonPoses == null)					{						skeletonPoses = new Dictionary();											}					skeletonPosesFromAnimation(skeletonPoses, daeAnimation);				}								if (skeletonPoses != null)				{					// sort poses based on keyFrameTime (the key in the skeletonPoses Dictionary)					var keyFrameTimes:Vector.<String> = new Vector.<String>;					var keyFrameTime:String;					for (keyFrameTime in skeletonPoses)					{						keyFrameTimes.push(keyFrameTime);					}										// temp use URI to identify animation sequence					var skeletonAnimationSequence:SkeletonAnimationSequence = new SkeletonAnimationSequence(this.uri); 					var sortedKeyFrameTimes:Vector.<String> = keyFrameTimes.sort(sortStringsAsNumbers);					var duration:Number = Number(sortedKeyFrameTimes[1])- Number(sortedKeyFrameTimes[0]);					for each (keyFrameTime in sortedKeyFrameTimes)					{						var skeletonPose:SkeletonPose = new SkeletonPose();						var jointPoses:Dictionary = skeletonPoses[keyFrameTime];						for (var jointName:String in jointPoses)						{							// find out which jointIndex this skeleton has for this jointName							var jointIndex:int = _skeleton.jointIndexFromName(jointName);							if (jointIndex != -1)							{								var jointPose:JointPose = jointPoses[jointName];								skeletonPose.jointPoses[jointIndex] = jointPose;							}							else							{								trace("-- [", filenameFromPath(this.uri),"] ERROR: jointName", jointName, "not in provided skeleton!");							}						}												skeletonAnimationSequence.addFrame(skeletonPose, duration);					}										var traceSerializer:TraceSerializer = new TraceSerializer();					Serialize.serializeSkeletonAnimationSequence(skeletonAnimationSequence, traceSerializer);				}			}			_daeParsingState++; // to 4		}				private function sortStringsAsNumbers(a:String, b:String):Number		{			if (Number(a) < Number(b))			{				return -1;			}			else if (Number(a) > Number(b))			{				return 1;			}			else			{				return 0;			}		}				private function applyMaterialParams(material:DefaultMaterialBase, daeLambert:DaeLambert):void		{			//daeLambert.emission			//daeLambert.transparent			//daeLambert.transparency						if (daeLambert.ambient.color)			{				material.ambientColor = buildColor(daeLambert.ambient.color);			}						if (daeLambert.diffuse.color)			{				material.diffuseMethod.diffuseColor = buildColor(daeLambert.diffuse.color);			}						if (daeLambert is DaePhong)			{				var daePhong:DaePhong = daeLambert as DaePhong;								if (daePhong.specular.color)				{					material.specularColor = buildColor(daePhong.specular.color);				}								//daePhong.shininess				//daePhong.reflective				//daePhong.reflectivity			}		}				private function matrixFromTransform(matrix:Matrix3D, daeTransform:DaeTransform):void		{			var v:Vector.<Number> = daeTransform.data;			switch (daeTransform.nodeName)			{				case "rotate":					matrix.appendRotation(v[3], new Vector3D(v[0], v[1], v[2]));					break;				case "scale":					matrix.appendScale(v[0], v[1], v[2]);					break;				case "translate":					matrix.appendTranslation(v[0], v[1], v[2]);					break;				case "matrix":					matrix.append(matrix3DFromColladaData(v));					break;				// missing at least				// "lookat"				// "skew"				default:					throw new Error("Unknown transform type: " + daeTransform.nodeName);			}		}				private function matrixFromNode(matrix:Matrix3D, daeNode:DaeNode):void		{			// setup the initial transform - there may be several that collada stacks together here.			for each (var daeTransform:DaeTransform in daeNode.transforms)			{				matrixFromTransform(matrix, daeTransform);			}		}				private function skeletonAndDefaultPoseFromNode(skeleton:Skeleton, skeletonDefaultPose:SkeletonPose, daeNode:DaeNode, parentJointIndex:int):void		{			var thisSkeletonJoint:SkeletonJoint = new SkeletonJoint();			thisSkeletonJoint.parentIndex = parentJointIndex;			thisSkeletonJoint.name = daeNode.name;			var jointIndex:int = skeleton.joints.push(thisSkeletonJoint);						var nodeTransform:Matrix3D = new Matrix3D();			matrixFromNode(nodeTransform, daeNode);						var orientation:Quaternion = new Quaternion();			orientation.fromMatrix(nodeTransform);			var translation:Vector3D = nodeTransform.position;						var thisJointPose:JointPose = new JointPose();			thisJointPose.name = daeNode.name;			skeletonDefaultPose.jointPoses.push(thisJointPose);			thisJointPose.orientation = orientation;			thisJointPose.translation = translation;						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				skeletonAndDefaultPoseFromNode(skeleton, skeletonDefaultPose, daeChildNode, jointIndex);			}		}				private function skeletonPosesFromAnimation(skeletonPoses:Dictionary, daeAnimation:DaeAnimation):void		{			for each (var daeChannel:DaeChannel in daeAnimation.channels)			{				var jointName:String = daeChannel.targetID;				var inputDaeSource:DaeSource = daeChannel.sampler.input; // keyframe time values				var outputDaeSource:DaeSource = daeChannel.sampler.output; // pose matrices				// TODO!				//var interpolationsDaeSource:DaeSource = daeChannel.sampler.interpolations; // interpolation type for animation between poses								// TODO: properly handle/bake together multiple daeChannel - at this point, our data only contains one daeChannel per anim/joint				var inputIndex:uint;				for each (var input:Number in inputDaeSource.dataFloat)				{					// retrieve or create Vector.<JointPose> for this input (time)					// we do this instead of SkeletonPose (at this time) because 					// there may be more than one daeChannel affecting the same joints.					var inputString:String = String(input);					//var jointPoses:Vector.<JointPose>;					var jointPoses:Dictionary;					if (skeletonPoses.hasOwnProperty(inputString))					{						jointPoses = skeletonPoses[inputString];					}					else					{						//jointPoses = new Vector.<JointPose>();						jointPoses = new Dictionary();						skeletonPoses[inputString] = jointPoses;					}										var jointPose:JointPose = new JointPose();					jointPose.name = jointName;										var poseTransform:Matrix3D;					if (outputDaeSource.accessor.params[0].type == "float")					{						// HACK, possibly not right.  If float array shows up here, I guess these might be always 1's, and that that means "identity".  Dunno.						poseTransform = new Matrix3D();											}					else					{						// get matrix from outputDaeSource						poseTransform = matrix3DFromColladaData(outputDaeSource.dataFloat[inputIndex]);					}										jointPose.translation = poseTransform.position;					var orientation:Quaternion = new Quaternion();					orientation.fromMatrix(poseTransform);					jointPose.orientation = orientation;										//jointPoses.push(jointPose);					if (jointPoses.hasOwnProperty(jointPose.name))					{						trace("-- [", filenameFromPath(this.uri),"] ERROR: jointName", jointPose.name, "already exists in pose!");					}					jointPoses[jointPose.name] = jointPose;					inputIndex++;				}			}		}				private function meshFromNode(instance:Mesh, daeNode:DaeNode):void		{			var daeGeometry:DaeGeometry;			var daeInstanceMaterial:DaeInstanceMaterial;			var daePrimitive:DaePrimitive;			var daeBindVertexInput:DaeBindVertexInput;			var indexIsDupeOf:Vector.<int>;						matrixFromNode(instance.transform, daeNode);						instance.name = daeNode.name;						if (daeNode.controllerInstances.length)			{				for each (var daeInstanceController:DaeInstanceController in daeNode.controllerInstances)				{					var daeController:DaeController = daeNode.document.controllers[daeInstanceController.url];										// controllers, can be of type 'skin' or 'morph'					if (daeController.skin)					{						instance.transform.append(matrix3DFromColladaData(daeController.skin.bind_shape_matrix.data));						daeGeometry = daeNode.document.geometries[daeController.skin.source];						for each (daeInstanceMaterial in daeInstanceController.bindMaterial.instanceMaterials)						{							for each (daePrimitive in daeGeometry.mesh.primitives)							{								// pick out the right daePrimitive for this daeInstanceMaterial								if (daeInstanceMaterial.symbol == daePrimitive.material)								{									var skinnedSubGeometry:SkinnedSubGeometry = new SkinnedSubGeometry(daeController.skin.joints.length);									instance.geometry.addSubGeometry(skinnedSubGeometry);									// DaeInstanceMaterial.target corresponds to DaeMaterial.name									// retrieve correct texcoord-set for the material, and the correct BindVertexInput									// TODO: input_semantic here probably shouldn't be hardcoded.									// TODO: any way to eliminate _texCoordSets[] dictionary?									daeBindVertexInput = daeInstanceMaterial.findBindVertexInput(_texCoordSets[daeInstanceMaterial.target], "TEXCOORD");									if (daeBindVertexInput == null) throw new Error("DaeBindVertexInput null!");									indexIsDupeOf = determineDupes(daePrimitive, daeBindVertexInput.input_set);									applyGeometry(skinnedSubGeometry, daePrimitive, indexIsDupeOf, daeBindVertexInput.input_set, daeInstanceMaterial, instance);									applyJoints(skinnedSubGeometry, daeController.skin);																		// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.									break;								}							}						}					}					else if (daeController.morph)					{						throw new Error("morph!");					}					else					{						throw new Error("A COLLADA controller should be of type <skin> or <morph>!");					}										// dunno yet how to handle multiple controllers.					break;				}			}			else if (daeNode.geometryInstances.length)			{				for each (var daeInstanceGeometry:DaeInstanceGeometry in daeNode.geometryInstances)				{					daeGeometry = daeNode.document.geometries[daeInstanceGeometry.url];					for each (daeInstanceMaterial in daeInstanceGeometry.bindMaterial.instanceMaterials)					{						for each (daePrimitive in daeGeometry.mesh.primitives)						{							// pick out the right daePrimitive for this daeInstanceMaterial							if (daeInstanceMaterial.symbol == daePrimitive.material)							{								var subGeometry:SubGeometry = new SubGeometry();								instance.geometry.addSubGeometry(subGeometry);								// DaeInstanceMaterial.target corresponds to DaeMaterial.name								// retrieve correct texcoord-set for the material, and the correct BindVertexInput								// TODO: input_semantic here probably shouldn't be hardcoded.								// TODO: any way to eliminate _texCoordSets[] dictionary?								daeBindVertexInput = daeInstanceMaterial.findBindVertexInput(_texCoordSets[daeInstanceMaterial.target], "TEXCOORD");								if (daeBindVertexInput == null) throw new Error("DaeBindVertexInput null!");								indexIsDupeOf = determineDupes(daePrimitive, daeBindVertexInput.input_set);								applyGeometry(subGeometry, daePrimitive, indexIsDupeOf, daeBindVertexInput.input_set, daeInstanceMaterial, instance);																// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.								break;							}						}					}				}			}						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				var child:Mesh = new Mesh();				instance.addChild(child);				meshFromNode(child, daeChildNode);			}		}				private function determineDupes(daePrimitive:DaePrimitive, uvInputSet:int):Vector.<int>		{			var vertexIndexes:Vector.<Vector.<uint>> = daePrimitive.triangles;			var normalIndexes:Vector.<Vector.<uint>> = daePrimitive.normals;			var uvIndexes:Vector.<Vector.<uint>> = daePrimitive.getUVSet(uvInputSet);						// 3 vertices (indexes, really) per triangle			// hence, numIndexData here will be 3x number of triangles			var numTriangles:uint = daePrimitive.triangles.length;			var numIndexData:uint = numTriangles*3;						// looks for unique combinations of vertIndex, normIndex, uvIndex			// uniques of those 3 items will indicate the minimum number of indexes we need for the subGeometry we're building.			var indexIsDupeOf:Vector.<int> = new Vector.<int>(numIndexData);						var i:uint, j:uint;						for (i = 0; i < numIndexData; i++)			{				// initialize to "not a dupe"				indexIsDupeOf[i] = -1;			}						for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnumi : int = i / 3; // tri num					var vnumi : int = i % 3; // vert num (within tri)					for (j = i + 1; j < numIndexData; j++)					{						var tnumj : int = j / 3; // tri num						var vnumj : int = j % 3; // vert num (within tri)						if ((vertexIndexes[tnumi][vnumi] == vertexIndexes[tnumj][vnumj]) &&							(normalIndexes[tnumi][vnumi] == normalIndexes[tnumj][vnumj]) &&							(uvIndexes[tnumi][vnumi]     == uvIndexes[tnumj][vnumj]))						{							// dupe vertexes are defined as equal vertex,normal,uv indexes.							indexIsDupeOf[j] = i;						}					}				}			}						return indexIsDupeOf;		}				// this will copy mesh data defined in daePrimitive to subGeometry.		// * daePrimitive is the higher level definition of the mesh.		// * indexIsDupeOf is vertex remapping table - indexed via oldVertexIndex, storing newVertexIndex		// * uvInputSet is index into uvSets		// * daeInstanceMaterial is needed for two reasons:		//   1. for the actual material ID, for material assignment.		//   2. for the selection of proper UV's		// * instance is the mesh to which the subGeometry is attached		private function applyGeometry(subGeometry:SubGeometry, daePrimitive:DaePrimitive, indexIsDupeOf:Vector.<int>,																	 uvInputSet:int, daeInstanceMaterial:DaeInstanceMaterial, instance:Mesh):void		{			// find which SubMesh has this SubGeometry (oogly - why did Away3D do it this way???)			var subMesh:SubMesh;			for each (subMesh in instance.subMeshes)			{				if (subMesh.subGeometry == subGeometry)				{					break;				}			}						// assign proper material to this subMesh			subMesh.material = _materials[daeInstanceMaterial.target];						var vertexIndexes:Vector.<Vector.<uint>> = daePrimitive.triangles;			var normalIndexes:Vector.<Vector.<uint>> = daePrimitive.normals;			var uvIndexes:Vector.<Vector.<uint>> = daePrimitive.getUVSet(uvInputSet);						// 3 vertices (indexes, really) per triangle			// hence, numIndexData here will be 3x number of triangles			var numTriangles:uint = daePrimitive.triangles.length;			var numIndexData:uint = numTriangles*3;						var indexData:Vector.<uint> = new Vector.<uint>();			var vertexData:Vector.<Number> = new Vector.<Number>();			var normalData:Vector.<Number> = new Vector.<Number>();			var uvData:Vector.<Number> = new Vector.<Number>();						var newVertexIndex : uint = 0;			var normalSource : DaeSource = daePrimitive.document.sources[daePrimitive.normalInput.source];			var uvInput : DaeInput = daePrimitive.getTexCoordInput(uvInputSet);			var uvSource : DaeSource = daePrimitive.document.sources[uvInput.source];						var i:uint;			for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnum : int = i / 3; // tri num					var vnum : int = i % 3; // vert num (within tri)										indexData.push(newVertexIndex);										var oldVertexIndex : uint = vertexIndexes[tnum][vnum];					vertexData.push(daePrimitive.vertices.source.dataFloat[oldVertexIndex][0]);					vertexData.push(daePrimitive.vertices.source.dataFloat[oldVertexIndex][1]);					vertexData.push(daePrimitive.vertices.source.dataFloat[oldVertexIndex][2]);										var oldNormalIndex : uint = normalIndexes[tnum][vnum];					normalData.push(normalSource.dataFloat[oldNormalIndex][0]);					normalData.push(normalSource.dataFloat[oldNormalIndex][1]);					normalData.push(normalSource.dataFloat[oldNormalIndex][2]);										var oldUVIndex : uint = uvIndexes[tnum][vnum];					uvData.push(      uvSource.dataFloat[oldUVIndex][0]);					uvData.push(1.0 - uvSource.dataFloat[oldUVIndex][1]); // must flip the v around.										newVertexIndex++;				}				else				{					// indexIsDupeOf[] holds index into indexData, and is LOWEST duplicate vert (including vert,normal,uv).					// indexData[] holds newVertexIndex					indexData.push(indexData[indexIsDupeOf[i]]);				}			}						if ((vertexData.length != normalData.length) ||				((vertexData.length / 3) != (uvData.length / 2)))			{				trace("-- [", filenameFromPath(this.uri),"] vertexData, normalData, and uvData should have same relative number of elements");				trace("-- [", filenameFromPath(this.uri),"]  vertexData", vertexData.length / 3, "normalData", normalData.length / 3, "uvData", uvData.length / 2);			}						for (i = 0; i < indexData.length; i++)			{				if (indexData[i] > (vertexData.length / 3) - 1)				{					trace("-- [", filenameFromPath(this.uri),"] index value (", indexData[i], ") bigger than largest of vertex/normal/uv index (", (vertexData.length / 3) - 1, ")"); 				}			}						subGeometry.updateIndexData(indexData); // triangle indices (into vertex, normal, and uv data)			subGeometry.updateVertexData(vertexData);			subGeometry.updateVertexNormalData(normalData);			subGeometry.updateUVData(uvData);		}				// Comment from Richard Olsson on away3d team.		// As far as skeletons are concerned, there are a couple of things that I've bumped into and that I have had to work around.		// Most importantly (and least obviously) you need to think of three things concerning weights: 		//  All vertices must have the same number of weights (so pad with zero weights if necessary.)		//  A non-zero weight may never come after a zero weight, because the algorithm stops reading weights for a vertex after the first zero weight.		//  All weights must be normalized so that if a vertex as three weights, the sum of those three weights are one.				// TODO: eventually vertexGroups play a part here		private function applyJoints(skinnedSubGeometry:SkinnedSubGeometry, daeSkin:DaeSkin):void		{			var maxJointsPerVertex : uint = daeSkin.joints.length;			var numIndices : uint = skinnedSubGeometry.numTriangles * 3;			// this seems like it's wrong - should be Vector.<uint> if its really indexes?!?!			var jointIndexData : Vector.<Number>   = new Vector.<Number>(numIndices * maxJointsPerVertex, true);			var jointWeightsData : Vector.<Number> = new Vector.<Number>(numIndices * maxJointsPerVertex, true);						// TODO, what to do with daeSkin.bind_shape_matrix			var localJointIndex:uint = 0; // jointIndex just for this file - might be different if many colladas are merged			for each (var jointNames:Vector.<String> in daeSkin.joints)			{				var jointName:String = jointNames[0];				var jointIndex:int = _skeleton.jointIndexFromName(jointName); // we need the index - or else we'd simply call jointFromName()				if (jointIndex != -1)				{					var joint:SkeletonJoint = _skeleton.joints[jointIndex];					var daeBlendWeights:Vector.<DaeBlendWeight> = daeSkin.getBlendWeightsForJoint(jointName); // inside joints vector is always one element long										var invBindMatrix : Matrix3D = new Matrix3D();					matrixFromTransform(invBindMatrix, daeSkin.inv_bind_matrix[localJointIndex]);					joint.inverseBindPose = invBindMatrix.rawData;					for each (var daeBlendWeight:DaeBlendWeight in daeBlendWeights)					{						var indexIntoDatas : uint = (daeBlendWeight.vertexIndex * maxJointsPerVertex) + jointIndex;						// jointIndexes need to be multiplied by 3 (amount of matrix registers)						// NOTE: this came from NSSSkinMesh example code						jointIndexData  [indexIntoDatas] = jointIndex * 3;						jointWeightsData[indexIntoDatas] = daeBlendWeight.weight;					}				}				else				{					trace("-- [", filenameFromPath(this.uri),"] ERROR: jointName", jointName, "not defined in skeleton!");				}								localJointIndex++;			}						skinnedSubGeometry.jointIndexData = jointIndexData;			skinnedSubGeometry.jointWeightsData = jointWeightsData;		}				/**		 * Build a color from RGB values.		 * 		 * @param	rgb		 *  		 * @return		 */		private function buildColor(daeColor:DaeColor):uint		{			var r:uint = daeColor.r * 0xff;			var g:uint = daeColor.g * 0xff;			var b:uint = daeColor.b * 0xff;			return (r<<16|g<<8|b);		}				private function matrix3DFromColladaData(rowMajorDataFromCollada:Vector.<Number>):Matrix3D		{			var result : Matrix3D = new Matrix3D();			var columnMajorData : Vector.<Number> = result.rawData;						// collada data is in row-major order.  Matrix3D expects column-major.  transpose here			columnMajorData[0]  = rowMajorDataFromCollada[0];			columnMajorData[1]  = rowMajorDataFromCollada[4];			columnMajorData[2]  = rowMajorDataFromCollada[8];			columnMajorData[3]  = rowMajorDataFromCollada[12];			columnMajorData[4]  = rowMajorDataFromCollada[1];			columnMajorData[5]  = rowMajorDataFromCollada[5];			columnMajorData[6]  = rowMajorDataFromCollada[9];			columnMajorData[7]  = rowMajorDataFromCollada[13];			columnMajorData[8]  = rowMajorDataFromCollada[2];			columnMajorData[9]  = rowMajorDataFromCollada[6];			columnMajorData[10] = rowMajorDataFromCollada[10];			columnMajorData[11] = rowMajorDataFromCollada[14];			columnMajorData[12] = rowMajorDataFromCollada[3]; // translation x			columnMajorData[13] = rowMajorDataFromCollada[7]; // translation y			columnMajorData[14] = rowMajorDataFromCollada[11]; // translation z			columnMajorData[15] = rowMajorDataFromCollada[15];						return result;		}	}}