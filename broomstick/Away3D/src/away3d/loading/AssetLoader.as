package away3d.loading{	import away3d.events.LoaderEvent;	import away3d.loading.parsers.ParserBase;	import away3d.loading.parsers.ParserDataFormat;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.utils.ByteArray;		/**	 * The AssetLoader is used to load resources natively supported by Away3D, such as scene graph objects (Mesh,	 * ObjectContainer3D, Scene3D, etc), materials, animations, ... It supports autodetection of the following	 * file types:	 * <ul>	 * <li>Away Data version 1 ascii and version 2 binary(.awd). AWD1 BSP unsupported</li>	 * <li>AC3D (.ac)</li>	 * <li>Collada (.dae)</li>	 * <li>Quake 2 MD2 models (.md2)</li>	 * <li>Doom 3 MD5 meshes (.md5mesh)</li>	 * <li>Doom 3 MD5 animation clips (.md5anim)</li>	 * <li>Wavefront OBJ (.obj)</li>	 * <li>3DMax (.3ds)</li>	 * <li>Images (.jpg, .png)</li>	 * </ul>	 *	 * For other types, if a parser is available, or when specific options need to be passed to it, the parser should be	 * passed using the load or loadData methods.	 *	 * While AssetLoader can be used directly, it's recommended to use the ResourceManager class instead.	 *	 * @see away3d.loading.ResourceManager	 */	public class AssetLoader extends EventDispatcher	{		private var _parser : ParserBase;		private var _url : String;		private var _fileExtension : String;		private var _fileName : String;				private var _event_verbosity : int;		private var _parsers : Vector.<Class>;				public static const SILENT : int = 0;		public static const LEVEL_1 : int = 1;		public static const LEVEL_2 : int = 2;						/**		 * Creates a new AssetLoader object.		 */		public function AssetLoader(parsers:Vector.<Class>)		{			_event_verbosity = SILENT;			_parsers = parsers;		}				/**		 * The threshold that define which events are dispatched.		 */		public function get eventVerbosity() : int		{			return _event_verbosity;		}				public function set eventVerbosity(val : int) : void		{			_event_verbosity = val;		}						/**		 * Load a resource from a file.		 * @param urlRequest The URLRequest object containing the URL of the object to be loaded.		 * @param parser An optional parser object that will translate the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.		 */		public function load(urlRequest : URLRequest, parser : ParserBase = null) : void		{			var urlLoader : URLLoader;			var dataFormat : String;						_url = urlRequest.url;			decomposeFilename(_url);						if (parser) _parser = parser;						if (!_parser) _parser = getParserFromSuffix();						if (!_parser){								if(hasEventListener(LoaderEvent.LOAD_ERROR))					this.dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_ERROR, null, _url, "Unsupported file type:"+_fileName));							} else {								if (_parser) {					switch (_parser.dataFormat) {						case ParserDataFormat.BINARY:							dataFormat = URLLoaderDataFormat.BINARY;							break;						case ParserDataFormat.PLAIN_TEXT:							dataFormat = URLLoaderDataFormat.TEXT;							break;					}									} else {					// Always use BINARY for unknown file formats. The thorough					// file type check will determine format after load, and if					// binary, a text load will have broken the file data.					dataFormat = URLLoaderDataFormat.BINARY;				}								urlLoader = new URLLoader();				urlLoader.dataFormat = dataFormat;				urlLoader.addEventListener(Event.COMPLETE, handleUrlLoaderComplete);				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, handleUrlLoaderError);				urlLoader.load(urlRequest);			}		}				/**		 * Loads a resource from already loaded data.		 * @param data The data to be parsed. Depending on the parser type, this can be a ByteArray, String or XML.		 * @param uri The identifier (url or id) of the object to be loaded, mainly used for resource management.		 * @param parser An optional parser object that will translate the data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.		 */		public function parseData(data : *, uri : String, parser : ParserBase = null) : void		{			// todo: guess parser from header/content using guessTypeThorough			if (parser) _parser = parser;			_parser ||= getParserFromData(data, uri);			parse(data);		}				/**		 * A reference to the parser that will translate the loaded data into a usable resource.		 */		public function get parser() : ParserBase		{			return _parser;		}				/**		 * A list of dependencies that need to be loaded and resolved for the loaded object.		 */		public function get dependencies() : Vector.<ResourceDependency>		{			return _parser.dependencies;		}				/**		 * The object that will contain all the loaded and parsed data.		 */		public function get handle() : IResource		{			return _parser.handle;		}				/**		 * Splits a url string into base and extension.		 * @param url The url to be decomposed.		 */		private function decomposeFilename(url : String) : void		{			var base : String;			var i : int = url.lastIndexOf('.');						// Get rid of query string if any and extract suffix			base = (url.indexOf('?')>0)? url.split('?')[0] : url;			_fileExtension = base.substr(i + 1).toLowerCase();			_fileName = base.substr(0, i);		}				/**		 * Guesses the parser to be used based on the file extension.		 * @return An instance of the guessed parser.		 */		private function getParserFromSuffix() : ParserBase		{			var len : uint = _parsers.length;						// go in reverse order to allow application override of default parser added in Away3D proper			for (var i : int = len-1; i >= 0; i--)				if (_parsers[i].supportsType(_fileExtension)) return new _parsers[i](_fileName);						return null;		}				/**		 * Guesses the parser to be used based on the file contents.		 * @param data The data to be parsed.		 * @param uri The url or id of the object to be parsed.		 * @return An instance of the guessed parser.		 */		private function getParserFromData(data : *, uri : String) : ParserBase		{			var len : uint = _parsers.length;						// go in reverse order to allow application override of default parser added in Away3D proper			for (var i : int = len-1; i >= 0; i--)				if (_parsers[i].supportsData(data))					return new _parsers[i](uri);						return null;		}				/**		 * Cleanups		 */		private function removeListeners(urlLoader:URLLoader) : void		{			urlLoader.removeEventListener(Event.COMPLETE, handleUrlLoaderComplete);			urlLoader.removeEventListener(IOErrorEvent.IO_ERROR, handleUrlLoaderError);		}				/**		 * Called when loading of a file has failed		 */		private function handleUrlLoaderError(event:IOErrorEvent) : void		{			var urlLoader : URLLoader = URLLoader(event.currentTarget);			removeListeners(urlLoader);						if(hasEventListener(LoaderEvent.LOAD_ERROR))				dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_ERROR, null, _url, event.text));						// if flash.net.URLLoader failed to load requested asset, then attempt to parse whatever data we got back anyway.			// do not do this for jpg or png files			/*var urlFile:String = _url.toLowerCase();			if(urlFile.indexOf("jpg") == -1 && urlFile.indexOf("png") == -1){				if (!_parser)					_parser = getParserFromData(urlLoader.data, _fileName);								parse(urlLoader.data);			}    */		}				/**		 * Called when loading of a file is complete		 */		private function handleUrlLoaderComplete(event : Event) : void		{			var urlLoader : URLLoader = URLLoader(event.currentTarget);			removeListeners(urlLoader);						// if AssetLoader hasn't already cached a parser, try to figure it out from loaded data			if (!_parser)				_parser = getParserFromData(urlLoader.data, _fileName);						parse(urlLoader.data);		}				/**		 * Initiates parsing of the loaded data.		 * @param data The data to be parsed.		 */		private function parse(data : *) : void		{			if(_parser){				_parser.eventVerbosity = _event_verbosity;				_parser.addEventListener(LoaderEvent.PARSE_COMPLETE, handleParserParseComplete);				switch (_parser.dataFormat) {					case ParserDataFormat.BINARY:						_parser.parseBytesAsync( ByteArray(data) );						break;					case ParserDataFormat.PLAIN_TEXT:						_parser.parseTextAsync( String(data) );						break;				}			} else{				var msg:String = "No parser defined. If embedded 3dfile, pass parser to constructor\nResourceManager.instance.parseData(new EmbeddedFile(), \"myurl/\", false, Max3DSParser);";				if(hasEventListener(LoaderEvent.LOAD_ERROR)){					this.dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_ERROR, null, "", msg) );				} else{					throw new Error(msg);				}			}		}				/**		 * Called when parsing is complete.		 */		private function handleParserParseComplete(event : LoaderEvent) : void		{			_parser.removeEventListener(LoaderEvent.PARSE_COMPLETE, handleParserParseComplete);			this.dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_COMPLETE, event.resource, _url));		}	}}