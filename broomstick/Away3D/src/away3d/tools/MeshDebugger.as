package away3d.tools{	import away3d.tools.data.MeshDebug;	import away3d.entities.Mesh;	import away3d.containers.Scene3D;	 	/**	* Helper Class for Mesh objects <code>MeshDebugger</code>	* Displays the normals, tangents and vertexNormals of a given mesh.	*/	public class MeshDebugger{		 		private var _meshesData : Vector.<MeshDebugData> = new Vector.<MeshDebugData>();		private var _colorNormals : uint = 0xFF3399;		private var _colorVertexNormals : uint = 0x66CCFF;		private var _colorTangents : uint = 0xFFCC00;		private var _lengthNormals:Number = 50;		private var _lengthTangents:Number = 50;		private var _lengthVertexNormals:Number = 50;		private var _dirty:Boolean;				public function debug(mesh:Mesh, scene:Scene3D, displayNormals:Boolean, displayVertexNormals:Boolean, displayTangents:Boolean):MeshDebugData		{			meshDebugData = isMeshDebug(mesh);						if(!meshDebugData){				var meshDebugData:MeshDebugData = new MeshDebugData();				meshDebugData.meshDebug = new MeshDebug();				meshDebugData.mesh = mesh;				meshDebugData.scene = scene;				meshDebugData.displayNormals = displayNormals;				meshDebugData.displayVertexNormals = displayVertexNormals;				meshDebugData.displayTangents = displayTangents;								if(displayNormals) meshDebugData.meshDebug.displayNormals(mesh, _colorNormals , _lengthNormals);				if(displayVertexNormals) meshDebugData.meshDebug.displayVertexNormals(mesh, _colorVertexNormals ,_lengthVertexNormals);				if(displayTangents) meshDebugData.meshDebug.displayTangents(mesh, _colorTangents ,_lengthTangents);								if(displayNormals  || displayVertexNormals || displayTangents){					meshDebugData.addChilded = true;					scene.addChild(meshDebugData.meshDebug);				}								meshDebugData.meshDebug.transform = meshDebugData.mesh.transform;								_meshesData.push(meshDebugData);			}						return meshDebugData;		}				public function set colorNormals(val:uint):void		{			_colorNormals = val;			unvalidate();		}		public function get colorNormals():uint		{			return _colorNormals;		}				public function set colorVertexNormals(val:uint):void		{			_colorVertexNormals = val;			unvalidate();		}		public function get colorVertexNormals():uint		{			return _colorVertexNormals;		}				public function set colorTangents(val:uint):void		{			_colorTangents = val;			unvalidate();		}		public function get colorTangents():uint		{			return _colorTangents;		}				public function set lengthVertexNormals(val:Number):void		{			val = val<0? 1 :val;			_lengthVertexNormals = val;			unvalidate();		}		public function get lengthVertexNormals():Number		{			return _lengthVertexNormals;		}				public function set lengthNormals(val:Number):void		{			val = val<0? 1 :val;			_lengthNormals = val;			unvalidate();		}		public function get lengthNormals():Number		{			return _lengthNormals;		}				public function set lengthTangents(val:Number):void		{			val = val<0? 1 :val;			_lengthTangents = val;			unvalidate();		}		public function get lengthTangents():Number		{			return _lengthTangents;		}		 		public function hideDebug(mesh:Mesh):void		{			for (var i:uint = 0; i<_meshesData.length;++i){				if(_meshesData[i].mesh == mesh && _meshesData[i].addChilded){					_meshesData[i].addChilded = false;					_meshesData[i].scene.removeChild(_meshesData[i].meshDebug); 					break;				}			}		}		public function showDebug(mesh:Mesh):void		{			for (var i:uint = 0; i<_meshesData.length;++i){				if(_meshesData[i].mesh == mesh && !_meshesData[i].addChilded ){					_meshesData[i].addChilded = true;					_meshesData[i].scene.addChild(_meshesData[i].meshDebug);					break;				}			}		}				public function removeDebug(mesh:Mesh):void		{			var meshDebugData:MeshDebugData;			for (var i:uint = 0; i<_meshesData.length;++i){				meshDebugData = _meshesData[i];				if(meshDebugData.mesh == mesh){										if(meshDebugData.addChilded)						meshDebugData.scene.removeChild(meshDebugData.meshDebug);											meshDebugData.meshDebug.clearAll();					meshDebugData.meshDebug = null;					meshDebugData = null;					_meshesData.splice(i, 1);					break;				}			}		}				public function update():void		{			var meshDebugData:MeshDebugData;			var tmpMDD:MeshDebugData;			for (var i:uint = 0; i<_meshesData.length;++i){				meshDebugData = _meshesData[i];				if(_dirty){										if(!tmpMDD)  tmpMDD = new MeshDebugData();											tmpMDD.mesh = meshDebugData.mesh;					tmpMDD.scene = meshDebugData.scene;					tmpMDD.displayNormals = meshDebugData.displayNormals;					tmpMDD.displayVertexNormals = meshDebugData.displayVertexNormals;					tmpMDD.displayTangents = meshDebugData.displayTangents;					tmpMDD.addChilded = meshDebugData.addChilded;					 					removeDebug(meshDebugData.mesh);					meshDebugData = debug(tmpMDD.mesh, tmpMDD.scene, tmpMDD.displayNormals, tmpMDD.displayVertexNormals, tmpMDD.displayTangents);										if(!tmpMDD.addChilded) hideDebug(meshDebugData.mesh);				}								meshDebugData.meshDebug.transform = meshDebugData.mesh.transform;			}						_dirty = false;		}				private function isMeshDebug(mesh:Mesh):MeshDebugData		{			var meshDebugData:MeshDebugData;			for (var i:uint = 0; i<_meshesData.length;++i){				meshDebugData = _meshesData[i];				if(meshDebugData.mesh == mesh)					return meshDebugData;			}						return null;		}				private function unvalidate():void		{			if(_dirty || _meshesData.length == 0) return;			_dirty = true;		}		 	}}class MeshDebugData {		import away3d.entities.Mesh;	import away3d.tools.data.MeshDebug;	import away3d.containers.Scene3D;		public var mesh:Mesh;	public var meshDebug:MeshDebug;	public var scene:Scene3D;	public var displayNormals:Boolean;	public var displayVertexNormals:Boolean;	public var displayTangents:Boolean;	public var addChilded:Boolean;}