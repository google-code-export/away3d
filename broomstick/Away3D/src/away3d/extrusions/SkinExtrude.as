package away3d.extrusions{	import away3d.core.base.data.UV;	import away3d.core.base.data.Vertex;	import away3d.core.base.Geometry;	import away3d.core.base.Object3D;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.errors.AbstractMethodError;	import away3d.materials.MaterialBase;	import away3d.entities.Mesh;	import away3d.tools.MeshHelper;		import flash.geom.Vector3D;	public class SkinExtrude extends Mesh	{		private static const LIMIT:uint = 64998;		private var _tmpVectors:Vector.<Number>;		private var _subGeometry:SubGeometry;		private var _indice:uint;		private var _uva:UV;		private var _uvb:UV;		private var _uvc:UV;		private var _uvd:UV;		private var _va:Vertex;		private var _vb:Vertex;		private var _vc:Vertex;		private var _vd:Vertex;		private var _uvs : Vector.<Number>;		private var _vertices : Vector.<Number>;		private var _indices : Vector.<uint>;				/*		* Class SkinExtrude generates (and becomes) a mesh from a multidimentional vector of vector3D's . <code>SkinExtrude</code>		*@param	material			MaterialBase. The SkinExtrude (Mesh) material		*@param	vectors			Vector.<Vector.<Vector3D>> Multidimentional vector of vectors holding the vector3d's. < <va0, va1>, <vb0, vb1> >		*@param	subdivision		uint. The subdivision between vectors. Default is 1.		*@param	recenter			Boolean. If the final mesh must be recentered. Default is false.		*@param	closepath		Boolean. If the last vector must be linked to the first vector. Default is false.		*@param	coverall			Boolean. If the mapping is stretched over the entire mesh or from vector to vector. Default is false.		*@param	flip				Boolean. If the faces need to be inverted. Default is false.		*/        public function SkinExtrude(material : MaterialBase, vectors:Vector.<Vector.<Vector3D>>, subdivision:uint = 1, recenter:Boolean = false, closepath:Boolean = false, coverall:Boolean = false, flip:Boolean = false)        {		 	_subGeometry = new SubGeometry();			super(material, new Geometry());			this.geometry.addSubGeometry(_subGeometry); 			if(vectors.length>1 && vectors[0].length>1 && vectors[1].length>1){				initHolders();				if(closepath && vectors.length <3) closepath = false;				generate(vectors, subdivision, coverall, closepath, flip);			} else{				throw new Error("SkinExtrude: 1 multidimentional Vector.<Vector.<Vector3D>> with minimum 2 children Vector.<Vector3D>. Each child Vector must hold at least 2 Vector3D.");			}			 			if(recenter) {				MeshHelper.applyPosition( this, (this.minX+this.maxX)*.5,  (this.minY+this.maxY)*.5, (this.minZ+this.maxZ)*.5);			} else {				x =  vectors[0][0].x;				y =  vectors[0][0].y;				z =  vectors[0][0].z;			}						_tmpVectors = null;        }				private function generate(vectors:Vector.<Vector.<Vector3D>>, subdivision:uint = 1,  coverall:Boolean = false, closepath:Boolean = false, flip:Boolean = false):void		{				var uvlength:int = (closepath)? vectors.length : vectors.length-1;			for(var i:int = 0;i<vectors.length-1;++i){				_tmpVectors = new Vector.<Number>();				extrude(vectors[i], vectors[i+1], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			if(closepath){				_tmpVectors = new Vector.<Number>();				extrude(vectors[vectors.length-1], vectors[0], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}						_subGeometry.updateVertexData(_vertices);			_subGeometry.updateIndexData(_indices);			_subGeometry.updateUVData(_uvs);			_uva = _uvb = _uvc = _uvd = null;			_va = _vb = _vc = _vd = null;			_uvs = _vertices = null;			_indices = null;		}					private function extrude(vectsA:Vector.<Vector3D>, vectsB:Vector.<Vector3D>, subdivision:uint, coverall:Boolean, vscale:Number, indexv:int, flip:Boolean):void		{			var i:int;			var j:int;			var k:int;			var stepx:Number;			var stepy:Number;			var stepz:Number;			 			var u1:Number;			var u2:Number;			var index:int = 0;			var vertIndice:uint;						var bu:Number = 0;			var bincu:Number = 1/(vectsA.length-1);			var v1:Number = 0;			var v2:Number = 0;			 			for( i = 0; i < vectsA.length; ++i){				stepx = (vectsB[i].x - vectsA[i].x) / subdivision;				stepy = (vectsB[i].y - vectsA[i].y) / subdivision;				stepz = (vectsB[i].z - vectsA[i].z)  / subdivision;				 				for( j = 0; j < subdivision+1; ++j)					_tmpVectors.push( vectsA[i].x+(stepx*j) , vectsA[i].y+(stepy*j), vectsA[i].z+(stepz*j));							}						for( i = 0; i < vectsA.length-1; ++i) {								u1 = bu;				bu += bincu;				u2 = bu;								for( j = 0; j < subdivision; ++j){										v1 = (coverall)? vscale+((j/subdivision)/indexv) :  j/subdivision;					v2 = (coverall)? vscale+(( (j+1)/subdivision)/indexv) :  (j+1)/subdivision;										_uva.u = u1					_uva.v = v1;					_uvb.u = u1;					_uvb.v = v2;					_uvc.u = u2;					_uvc.v = v2;					_uvd.u = u2;					_uvd.v = v1;										_va.x = _tmpVectors[vertIndice = (index+j)*3];					_va.y = _tmpVectors[vertIndice+1];					_va.z = _tmpVectors[vertIndice+2];										_vb.x  = _tmpVectors[vertIndice = (index+j + 1)*3];					_vb.y  = _tmpVectors[vertIndice+1];					_vb.z  = _tmpVectors[vertIndice+2];										_vc.x  = _tmpVectors[vertIndice = (index+j +  subdivision + 2 ) *3];					_vc.y  = _tmpVectors[vertIndice+1];					_vc.z  = _tmpVectors[vertIndice+2];										_vd.x  = _tmpVectors[vertIndice = (index+j +  subdivision + 1 )*3];					_vd.y  = _tmpVectors[vertIndice+1];					_vd.z  = _tmpVectors[vertIndice+2];					 					if(_vertices.length+18>LIMIT){						_subGeometry.updateVertexData(_vertices);						_subGeometry.updateIndexData(_indices);						_subGeometry.updateUVData(_uvs);												_subGeometry = new SubGeometry();						this.geometry.addSubGeometry(_subGeometry);						_uvs = new Vector.<Number>();						_vertices = new Vector.<Number>();						_indices = new Vector.<uint>();						_indice = 0;					}					 					if(flip){												_vertices.push(_va.x, _va.y, _va.z, _vb.x, _vb.y, _vb.z, _vc.x, _vc.y, _vc.z);						_uvs.push(_uva.u,_uva.v, _uvb.u, _uvb.v, _uvc.u, _uvc.v);												_vertices.push(_va.x, _va.y, _va.z, _vc.x, _vc.y, _vc.z, _vd.x, _vd.y, _vd.z);						_uvs.push(_uva.u,_uva.v, _uvc.u, _uvc.v, _uvd.u, _uvd.v);											} else {												_vertices.push(_vb.x, _vb.y, _vb.z, _va.x, _va.y, _va.z, _vc.x, _vc.y, _vc.z);						_uvs.push(_uvb.u, _uvb.v, _uva.u, _uva.v, _uvc.u, _uvc.v);						 						_vertices.push(_vc.x, _vc.y, _vc.z, _va.x, _va.y, _va.z, _vd.x, _vd.y, _vd.z);						_uvs.push(_uvc.u, _uvc.v, _uva.u, _uva.v, _uvd.u, _uvd.v);					}										for(k=0; k<6;++k){						_indices[_indice] = _indice;						_indice++;					}					 				}								index += subdivision +1;			}		}				private function initHolders():void		{				_indice = 0;			_uva = new UV(0,0);			_uvb = new UV(0,0);			_uvc = new UV(0,0);			_uvd = new UV(0,0);			_va = new Vertex(0,0,0);			_vb = new Vertex(0,0,0);			_vc = new Vertex(0,0,0);			_vd = new Vertex(0,0,0);			_uvs = new Vector.<Number>();			_vertices = new Vector.<Number>();			_indices = new Vector.<uint>();						_subGeometry.autoDeriveVertexNormals = true;            _subGeometry.autoDeriveVertexTangents = true;		}			}}