package away3d.materials.utils{   	import flash.display.BitmapData;	import flash.filters.BlurFilter;	import flash.filters.ColorMatrixFilter;	import flash.filters.ConvolutionFilter;	import flash.filters.DisplacementMapFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Matrix;	import flash.utils.setTimeout;	import flash.events.EventDispatcher;		import away3d.lights.PointLight3D;	import away3d.core.math.Number3D;	import away3d.core.base.Mesh;	import away3d.core.base.UV;	import away3d.core.base.Vertex;	import away3d.core.base.Face;	import away3d.core.base.Object3D;	import away3d.containers.ObjectContainer3D;	import away3d.arcane;	import away3d.events.TraceEvent;	import away3d.materials.BitmapMaterial;		use namespace arcane;		/**	 * Dispatched while the class is busy tracing. Note that the source can already be used for a Material	 * 	 * @eventType away3d.events.TraceEvent	 */	[Event(name="tracecomplete",type="away3d.events.TraceEvent")]		/**	 * Dispatched each time one bitmapdata is traced if more than one.	 * 	 * @eventType away3d.events.TraceEvent	 */	[Event(name="tracecount",type="away3d.events.TraceEvent")]    	/**	 * Dispatched when trace is done.	 * 	 * @eventType away3d.events.TraceEvent	 */	[Event(name="traceprogress",type="away3d.events.TraceEvent")]	  	public class LightPrebaker extends EventDispatcher{				private var _width:int;		private var _height:int;		private var _sourcemap:BitmapData;		private var _tracemap:BitmapData;		private var _alphasource:BitmapData;		private var _object3d:Object3D;		private var _mesh:Mesh;		private var _lines:Array;		private var _state:int = 0;		private var _step:int = 50;		private var _totalmesh:int =0;		private var _totalfaces:int =0;		private var _processedfaces:int =0;		private var _meshes:Array = [];		private var _bitmaps:Array = [];		private var n0:Number3D = new Number3D();		private var n1:Number3D = new Number3D();		private var n2:Number3D = new Number3D();		private var intPt0:Point = new Point();		private var intPt1:Point = new Point();		private var intPt2:Point = new Point();		private var rect:Rectangle = new Rectangle(0,0,1,1);				private var _position:Number3D = new Number3D();		private var _rotations:Number3D = new Number3D();		private var _rotate:Boolean;		private var _rad:Number = Math.PI / 180;		private var _sinx:Number;		private var _cosx:Number;		private var _siny:Number;		private var _cosy:Number;		private var _sinz:Number;		private var _cosz:Number;		private var _canceled:Boolean;				private var _aLights:Array;		private var _sceneAmbient:Number;				private var d0:Number3D = new Number3D();		private var d1:Number3D = new Number3D();		private var d2:Number3D = new Number3D();		private var dist0:Number;		private var dist1:Number;		private var dist2:Number;		 		private function generate(from:int, to:int):void		{			var i:int;			var j:int;						var p0:Point;			var p1:Point;			var p2:Point;			 			var col0r:int;			var col0g:int;			var col0b:int;			var col1r:int;			var col1g:int;			var col1b:int;			var col2r:int;			var col2g:int;			var col2b:int;						var coldis0:int;			var coldis1:int;			var coldis2:int;						var line0:Array;			var line1:Array;			var line2:Array;						var per0:Number;			var per1:Number;			var per2:Number;						var face:Face;			var fn:Number3D;			var row:int;			var s:int;			var e:int;			var colorpt:Point = new Point();			var lightFactor:Number;						function meet(pt:Point, x1:int,  y1:int, x2:int, y2:int, x3:int, y3:int, x4:int, y4:int):Point			{ 				var d:int = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);				if (d == 0)  return null;								pt.x = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;				pt.y = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;								return pt;			} 						function applyColorAt(x:int, y:int):void			{				 					if(_tracemap.getPixel(x, y) == 0){						colorpt.x = x;						colorpt.y = y;						 						var cross0:Point = meet(intPt0, line1[0].x,line1[0].y, line1[1].x, line1[1].y, p0.x, p0.y, x, y);						var cross1:Point = meet(intPt1, line2[0].x,line2[0].y, line2[1].x, line2[1].y, p1.x, p1.y, x, y);						var cross2:Point = meet(intPt2, line0[0].x,line0[0].y, line0[1].x, line0[1].y, p2.x, p2.y, x, y);						 						per0 = (cross0 == null)? 1 : Point.distance(cross0, colorpt) / Point.distance(p0, cross0 ) ; 						per1 = (cross1 == null)? 1 : Point.distance(cross1, colorpt) / Point.distance(p1, cross1 ) ;						per2 = (cross2 == null)? 1 : Point.distance(cross2, colorpt) / Point.distance(p2, cross2 ) ;						 						var pixcolor:uint = _sourcemap.getPixel(x, y);						var corigR:int = pixcolor >> 16 & 0xFF ;						var corigG:int = pixcolor >> 8 & 0xFF ;						var corigB:int = pixcolor & 0xFF;												if(per0+per1+per2 < 1.2){							var r:int =  (per0*col0r)+ (per1*col1r) + (per2*col2r);							var g:int = (per0*col0g) + (per1*col1g) + (per2*col2g);							var b:int = (per0*col0b) + (per1*col1b) + (per2*col2b);														r += corigR*_sceneAmbient;							g += corigG*_sceneAmbient;							b += corigB*_sceneAmbient;														_tracemap.setPixel(x, y,	((r>255)? 255 : r) << 16 | 																((g>255)? 255 : g)  << 8 | 																((b>255)? 255 : b) );						}					}					 			}						_sourcemap.lock();			var percentFalloff:Number = 1;						for(i = from;i<to;++i){				if(_canceled)					break;									coldis0 = coldis1 = coldis2 = 0;				face = _mesh.faces[i];				fn = face.normal;				n0 = averageNormals(face.v0, n0, fn);				p0 = new Point( face.uv0.u * _width,  (1 - face.uv0.v) * _height);				d0.x = face.v0.x;				d0.y = face.v0.y;				d0.z = face.v0.z;				if(_rotate){					d0 = rotateV(d0);				}				d0.x += _position.x;				d0.y += _position.y;				d0.z += _position.z;				for(j = 0;j<_aLights.length;++j){					dist0 = d0.distance(_aLights[j].lightposition);					percentFalloff =  (_aLights[j].lightfalloff-dist0)/_aLights[j].lightfalloff;					lightFactor = _aLights[j].lightposition.getAngle(n0);					if(j ==0 ){						if(percentFalloff < 0 || dist0 >_aLights[j].lightfalloff){							col0r = 0;							col0g = 0;							col0b = 0;						 						} else{							col0r = (_aLights[j].lightR *lightFactor)*percentFalloff;							col0g = (_aLights[j].lightG *lightFactor)*percentFalloff;							col0b = (_aLights[j].lightB *lightFactor)*percentFalloff;						}					} else if(percentFalloff > 0 && dist0 <_aLights[j].lightfalloff){						col0r +=  (_aLights[j].lightR *lightFactor)*percentFalloff;						col0g +=  (_aLights[j].lightG *lightFactor)*percentFalloff;						col0b += (_aLights[j].lightB *lightFactor)*percentFalloff; 					}				}												n1 = averageNormals(face.v1, n1, fn);				p1 = new Point( face.uv1.u * _width ,  (1 - face.uv1.v) * _height);				d1.x = face.v1.x;				d1.y = face.v1.y;				d1.z = face.v1.z;				if(_rotate){					d1 = rotateV(d1);				}				d1.x += _position.x;				d1.y += _position.y;				d1.z += _position.z;				for(j = 0;j<_aLights.length;++j){					dist1 = d1.distance(_aLights[j].lightposition);					percentFalloff =   (_aLights[j].lightfalloff- dist1)/_aLights[j].lightfalloff;					lightFactor = _aLights[j].lightposition.getAngle(n1);					if(j ==0){						if(percentFalloff < 0 || dist1 >_aLights[j].lightfalloff){							col1r = 0;							col1g = 0;							col1b = 0;						} else{							col1r = (_aLights[j].lightR*lightFactor)*percentFalloff;							col1g = (_aLights[j].lightG *lightFactor)*percentFalloff;							col1b = (_aLights[j].lightB *lightFactor)*percentFalloff;						}					} else if(percentFalloff > 0 && dist1 <_aLights[j].lightfalloff){						col1r += (_aLights[j].lightR *lightFactor)*percentFalloff;						col1g += (_aLights[j].lightG *lightFactor)*percentFalloff;						col1b += (_aLights[j].lightB *lightFactor)*percentFalloff;					}				}												n2 = averageNormals(face.v2, n2, fn);				p2 = new Point( face.uv2.u * _width , (1 - face.uv2.v) * _height);				d2.x = face.v2.x;				d2.y = face.v2.y;				d2.z = face.v2.z;				if(_rotate){					d2 = rotateV(d2);				}				d2.x += _position.x;				d2.y += _position.y;				d2.z += _position.z;				for(j = 0;j<_aLights.length;++j){					dist2 = d2.distance(_aLights[j].lightposition);					percentFalloff =   (_aLights[j].lightfalloff-dist2)/_aLights[j].lightfalloff;					lightFactor = _aLights[j].lightposition.getAngle(n2);					if(j ==0){						if(percentFalloff < 0 || dist2 >_aLights[j].lightfalloff){							col2r = 0;							col2g = 0;							col2b = 0;						} else{							col2r = (_aLights[j].lightR *lightFactor)*percentFalloff;							col2g = (_aLights[j].lightG *lightFactor)*percentFalloff;							col2b = (_aLights[j].lightB *lightFactor)*percentFalloff;						}					} else if(percentFalloff > 0 && dist2 <_aLights[j].lightfalloff){							col2r +=  (_aLights[j].lightR *lightFactor)*percentFalloff;							col2g += (_aLights[j].lightG *lightFactor)*percentFalloff;							col2b += (_aLights[j].lightB *lightFactor)*percentFalloff;					}				}								if(_aLights.length>1){					col0r /= _aLights.length;					col0g /= _aLights.length;					col0b /= _aLights.length;					col1r /= _aLights.length;					col1g /= _aLights.length;					col1b /= _aLights.length;					col2r /= _aLights.length;					col2g /= _aLights.length;					col2b /= _aLights.length;				}								_lines = [];				 				p0.x = Math.ceil(p0.x);				p1.x = Math.ceil(p1.x);				p2.x = Math.ceil(p2.x);				p0.y = Math.ceil(p0.y);				p1.y = Math.ceil(p1.y);				p2.y = Math.ceil(p2.y); 								setBounds(p0.x, p0.y, p1.x, p1.y, col0r, col0g, col0b, col1r, col1g, col1b, Point.distance(p0, p1));				setBounds(p1.x, p1.y, p2.x, p2.y, col1r, col1g, col1b, col2r, col2g, col2b, Point.distance(p1, p2));				setBounds(p2.x, p2.y, p0.x, p0.y, col2r, col2g, col2b, col0r, col0g, col0b, Point.distance(p2, p0));								line0 = [p0, p1];			 	line1 = [p1, p2];				line2 = [p2, p0];				 				_lines.sortOn("y", 16);								row = 0;				rect.x = _lines[0].x;				rect.y = _lines[0].y;				rect.width = 1;								for(j = 0;j < _lines.length; ++j)				{					if(row == _lines[j].y ){						if(s > _lines[j].x){							s = _lines[j].x;							rect.x = s;						} 						if(e < _lines[j].x){							e = _lines[j].x;						}						rect.width = e-s;						 					} else{						for(var k:int = rect.x;k<rect.x+rect.width;++k){							applyColorAt(k, rect.y);						}						s = _lines[j].x;						e = _lines[j].x;						row = _lines[j].y;						rect.x = _lines[j].x;						rect.y = _lines[j].y;						rect.width =0;					}				}			}						_sourcemap.unlock();			_state = i;						var te:TraceEvent;			if(!_canceled){								if(_state == _mesh.faces.length){					  					_lines = null;					grow();					//to do: replicating all other vars...					_mesh.material = new BitmapMaterial(_tracemap, {});					_totalmesh--;										if(_totalmesh == 0){												if(hasEventListener(TraceEvent.TRACE_COMPLETE)){							te = new TraceEvent(TraceEvent.TRACE_COMPLETE);							te.percent = 100;							te.percentPart = 100;							te.count = 0;							te.totalParts = _meshes.length;							dispatchEvent(te);						}						if(_sourcemap.transparent)							restoreAlpha();						_meshes = null;						_position = _rotations = null;											} else {												_processedfaces += _state;						if(hasEventListener(TraceEvent.TRACE_COUNT)){							te = new TraceEvent(TraceEvent.TRACE_COUNT);							te.count = _meshes.length-_totalmesh + 1;							te.totalParts = _meshes.length;							dispatchEvent(te);						}												if(_sourcemap.transparent)							restoreAlpha();													_state = 0;						draw(_meshes[_meshes.length-_totalmesh]);					}									} else{										if(hasEventListener(TraceEvent.TRACE_PROGRESS)){						te = new TraceEvent(TraceEvent.TRACE_PROGRESS);						te.percentPart = ( _state / _mesh.faces.length) *100;						te.percent = ( (_processedfaces+_state) / _totalfaces) *100;						te.count = _meshes.length-_totalmesh + 1;						te.totalParts = _meshes.length;						dispatchEvent(te);					}										setTimeout(generate, 1, _state, (_state+_step>_mesh.faces.length )? _mesh.faces.length : _state+_step);				}			} else{				trace("-- trace canceled");			}		}		private function restoreAlpha():void		{			intPt0.x = intPt0.y = 0;			_tracemap.copyChannel( _sourcemap, _sourcemap.rect, intPt0, 8, 8 );		}		 		private function averageNormals(v:Vertex, n:Number3D, fn:Number3D):Number3D		{			n.x = 0;			n.y = 0;			n.z = 0;			var m0:int = 0;			var m1:int = 0;			var m2:int = 0;			var f:Face;			var norm:Number3D;			var l:Number;						for(var i:int = 0;i<_mesh.faces.length;++i){				f = _mesh.faces[i];				if((f.v0.x == v.x && f.v0.y == v.y && f.v0.z == v.z) || (f.v1.x == v.x && f.v1.y == v.y && f.v1.z == v.z )|| (f.v2.x == v.x && f.v2.y == v.y && f.v2.z == v.z)){					norm = f.normal;										if((Math.max(fn.x, norm.x) - Math.min(fn.x, norm.x) < .8)){						n.x += norm.x;						m0++;					}										if((Math.max(fn.y, norm.y) - Math.min(fn.y, norm.y) < .8)){						n.y += norm.y;						m1++;					}										if((Math.max(fn.z, norm.z) - Math.min(fn.z, norm.z) < .8)){						n.z += norm.z;						m2++;					}									}			}			 			n.x /= m0;			n.y /= m1;			n.z /= m2;						n.normalize();			 			return n;		}				private function rotateV(v:Number3D):Number3D		{			var x:Number = v.x;			var y:Number = v.y;			var z:Number = v.z;			var y1:Number = y;			y = y1*_cosx+z*-_sinx;			z = y1*_sinx+z*_cosx;						var x1:Number = x;			x = x1*_cosy+z*_siny;			z = x1*-_siny+z*_cosy;					x1 = x;			x = x1*_cosz+y*-_sinz;			y = x1*_sinz+y*_cosz;						return v;		}				private function setBounds(x1:int,y1:int,x2:int,y2:int, r0:Number, g0:Number, b0:Number, r1:Number, g1:Number, b1:Number, dist:Number):void		{			var line:Array = [x1, y1];			var dist2:Number;			var scale:Number;						var r:Number;			var g:Number;			var b:Number;							var o:Object;			o = {x:x1, y:y1, col: r0 << 16| g0 << 8| b0};			_lines[_lines.length] = o;			o = {x:x2, y:y2, col: r1 << 16| g1 << 8| b1};			_lines[_lines.length] = o;			var error:int;			var dx:int;			var dy:int;			if (x1 > x2) {				var tmp:int = x1;				x1 = x2;				x2 = tmp;				tmp = y1;				y1 = y2;				y2 = tmp;			}			dx = x2 - x1;			dy = y2 - y1;			var yi:int = 1;			if (dx < dy) {				x1 ^= x2;				x2 ^= x1;				x1 ^= x2;				y1 ^= y2;				y2 ^= y1;				y1 ^= y2;			}			if (dy < 0) {				dy = -dy;				yi = -yi;			}			if (dy > dx) {				error = -(dy >> 1);				for (; y2 < y1; ++y2) {					dist2 = Math.sqrt((x2 - line[0]) * (x2 - line[0]) + (y2 - line[1]) * (y2 - line[1]));					scale = dist2/dist;					r =  (r1*scale)+(r0*(1-scale));					g =  (g1*scale)+(g0*(1-scale));					b =  (b1*scale)+(b0*(1-scale));					o = {x:x2, y:y2, col: r << 16| g << 8| b};					_lines[_lines.length] = o;					error += dx;					if (error > 0) {						x2 += yi;						dist2 = Math.sqrt((x2 - line[0]) * (x2 - line[0]) + (y2 - line[1]) * (y2 - line[1]));						scale = dist2/dist;						r =  (r1*scale)+(r0*(1-scale));						g =  (g1*scale)+(g0*(1-scale));						b =  (b1*scale)+(b0*(1-scale));						o = {x:x2, y:y2, col: r << 16| g << 8| b};						_lines[_lines.length] = o;						error -= dy;					}				}			} else {				error = -(dx >> 1);				for (; x1 < x2; ++x1) {					dist2 = Math.sqrt((x1 - line[0]) * (x1 - line[0]) + (y1 - line[1]) * (y1 - line[1]));					scale = dist2/dist;					r =  (r1*scale)+(r0*(1-scale));					g =  (g1*scale)+(g0*(1-scale));					b =  (b1*scale)+(b0*(1-scale));					o = {x:x1, y:y1, col: r << 16| g << 8| b};					_lines[_lines.length] = o;					error += dy;					if (error > 0) {						y1 += yi;						dist2 = Math.sqrt((x1 - line[0]) * (x1 - line[0]) + (y1 - line[1]) * (y1 - line[1]));						scale = dist2/dist;						r =  (r1*scale)+(r0*(1-scale));						g =  (g1*scale)+(g0*(1-scale));						b =  (b1*scale)+(b0*(1-scale));						o = {x:x1, y:y1, col: r << 16| g << 8| b};						_lines[_lines.length] = o;						error -= dx;					}				}			}		}						private function grow():void		{			var tmp0:BitmapData = new BitmapData(_tracemap.width, _tracemap.height, true, 0);			var tmp1:BitmapData = new BitmapData( _tracemap.width, _tracemap.height, false, 0);			var tmp2:BitmapData = tmp1.clone();			var tmp3:BitmapData = tmp0.clone();						var cf:ConvolutionFilter = new ConvolutionFilter(3,3,null,0,127);			var dp:DisplacementMapFilter = new DisplacementMapFilter( tmp1, tmp1.rect.topLeft, 1, 2, 2, 2, "color",0,0 );			var zeropt:Point = new Point(0,0);			var mat0:Array = [-1,0,1,-2,0,2,-1,0,1];			var mat1:Array = [-1,-2,-1,0,0,0,1,2,1];						for(var i:int = 0;i<3;++i){				tmp0.draw(_tracemap);				tmp0.threshold(tmp0, _tracemap.rect, zeropt,"==",0, 0xFFFFFF, 0xFFFFFF);								tmp1.copyChannel( tmp0, _tracemap.rect, _tracemap.rect.topLeft, 8, 1 );				tmp2.draw(tmp1);								cf .matrix = mat0;				tmp1.applyFilter(tmp1, tmp1.rect, tmp1.rect.topLeft, cf );								cf.matrix = mat1;				tmp2.applyFilter(tmp2, tmp2.rect, tmp2.rect.topLeft, cf );				tmp1.copyChannel( tmp2, tmp1.rect, tmp1.rect.topLeft, 1, 2 );				tmp3.draw(tmp0);				tmp0.applyFilter( tmp0, _tracemap.rect, _tracemap.rect.topLeft, dp ); 				tmp0.draw( tmp3); 				_tracemap.draw(tmp0);			}						tmp0.dispose();			tmp1.dispose();			tmp2.dispose();			tmp3.dispose();		}				private function draw(mesh:Mesh):void        {			_mesh = mesh;						_position.x = _mesh.scenePosition.x;			_position.y = _mesh.scenePosition.y;			_position.z = _mesh.scenePosition.z;			_rotations.x = _mesh.rotationX;			_rotations.y = _mesh.rotationY;			_rotations.z = _mesh.rotationZ;						var rotx:Number = _rotations.x * _rad;			var roty:Number = _rotations.y * _rad;			var rotz:Number = _rotations.z * _rad;			_sinx = Math.sin(rotx);			_cosx = Math.cos(rotx);			_siny = Math.sin(roty);			_cosy = Math.cos(roty);			_sinz = Math.sin(rotz);			_cosz = Math.cos(rotz);						if(_mesh.material is BitmapMaterial){				_sourcemap = (_mesh.material as BitmapMaterial).bitmap.clone();			} else {				_sourcemap = new BitmapData(256, 256, false, 0x00); 			}			_tracemap = _bitmaps[_meshes.length-_totalmesh];			_width = _tracemap.width;			_height = _tracemap.height;						_rotate = (_rotations.x != 0 &&_rotations.y != 0 &&_rotations.z != 0);						generate(0, (_step > _mesh.faces.length)?  _mesh.faces.length : _step);		}				private function meshInfo(object3d:Object3D):void		{			if(object3d as ObjectContainer3D){				var obj:ObjectContainer3D = (object3d as ObjectContainer3D);				for(var i:int =0;i<obj.children.length;++i){					 					if(obj.children[i] is ObjectContainer3D){						meshInfo(obj.children[i]);					} else{						registerMesh(obj.children[i] as Mesh);					}				}			} else {				registerMesh(object3d as Mesh);			}		}				private function registerMesh(mesh:Mesh):void		{			if(mesh.material is BitmapMaterial){				var source:BitmapData = (mesh.material as BitmapMaterial).bitmap;				_bitmaps.push(new BitmapData(source.width, source.height, source.transparent, (source.transparent)? 0xFF000000 : 0x00));			} else {				_bitmaps.push( new BitmapData(256, 256, false, 0x00)); 			}			_totalmesh++;			_totalfaces += mesh.faces.length;			_meshes.push(mesh);		}		/**		* Class LightPrebaker traces and merge light information into a given Mesh object BitmapMaterial. 		* If no material or of another type is found on a Mesh object, a default bitmapMaterial is generated and applied to it.		*		* @param	object3d				Object3D. The Mesh(es) materials to draw.		* @param	lights						Array of PointLight3D objects. Support at this time of development just lights of type PointLight3D;		* @param	sceneambient			[optional] Number. A number from 0 to 1. Defines the ambient value for the class. Light ambient values are not used. Default = .5.		* @param	maxfaces				[optional] int. To avoid that the player generates a timout error, the class handles the trace of faces stepwize. Default is 50 faces.		*/				public function LightPrebaker(object3d:Object3D, lights:Array, sceneambient:Number=.5, maxfaces:int = 50)        {					_object3d = object3d;			_sceneAmbient = sceneambient;			_state = 0;			_step = maxfaces * (1-(1/(2800/Math.max(_width, _height))));			_canceled = false;			_aLights = [];			var oLight:Object;			for(var i:int = 0; i<lights.length;++i){				oLight = {};				oLight.lightfalloff = lights[i].fallOff;				oLight.lightradius = lights[i].radius;				oLight.lightcolor = lights[i].color;				oLight.lightR = lights[i].color >> 16 & 0xFF;				oLight.lightG = lights[i].color >> 8 & 0xFF;				oLight.lightB = lights[i].color & 0xFF;				//oLight.ambient = sceneambient*lights[i].brightness;            	oLight.diffuse = lights[i].diffuse*lights[i].brightness;				oLight.specular = lights[i].specular*lights[i].brightness;				oLight.lightposition = new Number3D(lights[i].scenePosition.x, lights[i].scenePosition.y, lights[i].scenePosition.z) ;				_aLights.push(oLight);			}						meshInfo(object3d);						draw(_meshes[0]);		}				/**		 * getter that returns an array of all generated BitmapData objects		 // need add name of mesh somehow here.		 * 		 * @return	Array		An array holding all generated BitmapData objects in order of generation.		 */		public function getBitmaps():Array        {			return _bitmaps;        }				/**		 * Clears the array of BitmapData objects of the memory		 */		public function clearBitmaps():void        {			for(var i:int = 0;i< _bitmaps.length;++i){				_bitmaps[i].dispose();			}			_bitmaps = null;        }				/**		 * Clears the array of BitmapData objects of the memory		 */		public function cancel():void        {			_step = _mesh.faces.length+1;			_meshes = [];			_canceled = true;        }		 		/**		 * Default method for adding a traceprogress event listener		 * 		 * @param	listener		The listener function		 */		public function addOnTraceProgress(listener:Function):void        {			addEventListener(TraceEvent.TRACE_PROGRESS, listener, false, 0, false);        }				/**		 * Default method for removing a traceprogress event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnTraceProgress(listener:Function):void        {            removeEventListener(TraceEvent.TRACE_PROGRESS, listener, false);        }		/**		 * Default method for adding a tracecomplete event listener		 * 		 * @param	listener		The listener function		 */		public function addOnTraceComplete(listener:Function):void        {			addEventListener(TraceEvent.TRACE_COMPLETE, listener, false, 0, false);        }				/**		 * Default method for removing a tracecomplete event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnTraceComplete(listener:Function):void        {            removeEventListener(TraceEvent.TRACE_COMPLETE, listener, false);        }				/**		 * Default method for adding a tracecount event listener		 * 		 * @param	listener		The listener function		 */		public function addOnTraceCount(listener:Function):void        {			addEventListener(TraceEvent.TRACE_COUNT, listener, false, 0, false);        }				/**		 * Default method for removing a tracecount event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnTraceCount(listener:Function):void        {            removeEventListener(TraceEvent.TRACE_COUNT, listener, false);        }					}}