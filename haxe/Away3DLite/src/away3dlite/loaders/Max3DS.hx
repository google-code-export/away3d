package away3dlite.loaders;import away3dlite.containers.ObjectContainer3D;import away3dlite.core.base.Face;import away3dlite.core.base.Mesh;import away3dlite.core.utils.Cast;import away3dlite.core.utils.Debug;import away3dlite.loaders.data.FaceData;import away3dlite.loaders.data.GeometryData;import away3dlite.loaders.data.MaterialData;import away3dlite.loaders.data.MeshData;import away3dlite.loaders.data.MeshMaterialData;import flash.geom.Vector3D;import flash.Lib;import flash.utils.ByteArray;import flash.utils.Endian;//use namespace arcane;using away3dlite.namespace.Arcane;using away3dlite.haxeutils.HaxeUtils;/*** File loader for the 3DS file format.*/class Max3DS extends AbstractParser{	/** @private */	/*arcane*/ private override function prepareData(data:Dynamic):Void	{		max3ds = Cast.bytearray(data);		max3ds.endian = Endian.LITTLE_ENDIAN;				//first chunk is always the primary, so we simply read it and parse it		var chunk:Chunk3ds = new Chunk3ds();		readChunk(chunk);		parse3DS(chunk);				//build the meshes		buildMeshes();				//build materials		buildMaterials();	}		/** An array of bytes from the 3ds files. */	private var max3ds:ByteArray;	private var _materialData:MaterialData;	private var _face:Face;	private var _meshData:MeshData;	private var _geometryData:GeometryData;	private var _meshDictionary:Hash<MeshData>;	private var _moveVector:Vector3D;		//>----- Color Types --------------------------------------------------------		private static inline var AMBIENT:String = "ambient";	private static inline var DIFFUSE:String = "diffuse";	private static inline var SPECULAR:String = "specular";		//>----- Main Chunks --------------------------------------------------------		//private static inline var PRIMARY:Int = 0x4D4D;	private static inline var EDIT3DS:Int = 0x3D3D;  // Start of our actual objects	private static inline var KEYF3DS:Int = 0xB000;  // Start of the keyframe information		//>----- General Chunks -----------------------------------------------------		//private static inline var VERSION:Int = 0x0002;	//private static inline var MESH_VERSION:Int = 0x3D3E;	//private static inline var KFVERSION:Int = 0x0005;	private static inline var COLOR_F:Int = 0x0010;	private static inline var COLOR_RGB:Int = 0x0011;	//private static inline var LIN_COLOR_24:Int = 0x0012;	//private static inline var LIN_COLOR_F:Int = 0x0013;	//private static inline var INT_PERCENTAGE:Int = 0x0030;	//private static inline var FLOAT_PERC:Int = 0x0031;	//private static inline var MASTER_SCALE:Int = 0x0100;	//private static inline var IMAGE_FILE:Int = 0x1100;	//private static inline var AMBIENT_LIGHT:Int = 0X2100;		//>----- Object Chunks -----------------------------------------------------		private static inline var MESH:Int = 0x4000;	private static inline var MESH_OBJECT:Int = 0x4100;	private static inline var MESH_VERTICES:Int = 0x4110;	//private static inline var VERTEX_FLAGS:Int = 0x4111;	private static inline var MESH_FACES:Int = 0x4120;	private static inline var MESH_MATER:Int = 0x4130;	private static inline var MESH_TEX_VERT:Int = 0x4140;	//private static inline var MESH_XFMATRIX:Int = 0x4160;	//private static inline var MESH_COLOR_IND:Int = 0x4165;	//private static inline var MESH_TEX_INFO:Int = 0x4170;	//private static inline var HEIRARCHY:Int = 0x4F00;		//>----- Material Chunks ---------------------------------------------------		private static inline var MATERIAL:Int = 0xAFFF;	private static inline var MAT_NAME:Int = 0xA000;	private static inline var MAT_AMBIENT:Int = 0xA010;	private static inline var MAT_DIFFUSE:Int = 0xA020;	private static inline var MAT_SPECULAR:Int = 0xA030;	//private static inline var MAT_SHININESS:Int = 0xA040;	//private static inline var MAT_FALLOFF:Int = 0xA052;	//private static inline var MAT_EMISSIVE:Int = 0xA080;	//private static inline var MAT_SHADER:Int = 0xA100;	private static inline var MAT_TEXMAP:Int = 0xA200;	private static inline var MAT_TEXFLNM:Int = 0xA300;	//private static inline var OBJ_LIGHT:Int = 0x4600;	//private static inline var OBJ_CAMERA:Int = 0x4700;		//>----- KeyFrames Chunks --------------------------------------------------		private static inline var ANIM_HEADER:Int = 0xB00A;	private static inline var ANIM_OBJ:Int = 0xB002;	private static inline var ANIM_NAME:Int = 0xB010;	private static inline var ANIM_PIVOT:Int = 0xB013;	//private static inline var ANIM_POS:Int = 0xB020;	//private static inline var ANIM_ROT:Int = 0xB021;	//private static inline var ANIM_SCALE:Int = 0xB022;		/**	 * Array of mesh data objects used for storing the parsed 3ds data structure.	 */	private var meshDataList:Array<MeshData>;		/**	 * Read id and length of 3ds chunk	 * 	 * @param chunk 	 * 	 */			private function readChunk(chunk:Chunk3ds):Void	{		chunk.id = max3ds.readUnsignedShort();		chunk.length = max3ds.readUnsignedInt();		chunk.bytesRead = 6;	}		/**	 * Skips past a chunk. If we don't understand the meaning of a chunk id,	 * we just skip past it.	 * 	 * @param chunk	 * 	 */			private function skipChunk(chunk:Chunk3ds):Void	{		max3ds.position += chunk.length - chunk.bytesRead;		chunk.bytesRead = chunk.length;	}		/**	 * Read the base 3DS object.	 * 	 * @param chunk	 * 	 */			private function parse3DS(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case EDIT3DS:					parseEdit3DS(subChunk);				case KEYF3DS:					parseKey3DS(subChunk);				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		/**	 * Read the Edit chunk	 * 	 * @param chunk	 * 	 */	private function parseEdit3DS(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MATERIAL:					parseMaterial(subChunk);				case MESH:					_meshData = new MeshData();					readMeshName(subChunk);					_meshData.geometry = _geometryLibrary.addGeometry(_meshData.name);					_geometryData = _meshData.geometry;					parseMesh(subChunk);					meshDataList.push(_meshData);										if (centerMeshes) {												_geometryData.maxX = Math.NEGATIVE_INFINITY;						_geometryData.minX = Math.POSITIVE_INFINITY;						_geometryData.maxY = Math.NEGATIVE_INFINITY;						_geometryData.minY = Math.POSITIVE_INFINITY;						_geometryData.maxZ = Math.NEGATIVE_INFINITY;						_geometryData.minZ = Math.POSITIVE_INFINITY;						var i:Int = Std.int(_meshData.geometry.vertices.length/3);						var vertexX:Float;						var vertexY:Float;						var vertexZ:Float;						while (i-- > 0) {							vertexX = _meshData.geometry.vertices[i*3];							vertexY = _meshData.geometry.vertices[i*3+1];							vertexZ = _meshData.geometry.vertices[i*3+2];							if (_geometryData.maxX < vertexX)								_geometryData.maxX = vertexX;							if (_geometryData.minX > vertexX)								_geometryData.minX = vertexX;							if (_geometryData.maxY < vertexY)								_geometryData.maxY = vertexY;							if (_geometryData.minY > vertexY)								_geometryData.minY = vertexY;							if (_geometryData.maxZ < vertexZ)								_geometryData.maxZ = vertexZ;							if (_geometryData.minZ > vertexZ)								_geometryData.minZ = vertexZ;						}					}									default:					skipChunk(subChunk);			}						chunk.bytesRead += subChunk.length;		}	}		/**	 * Read the Key chunk	 * 	 * @param chunk	 * 	 */	private function parseKey3DS(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case ANIM_HEADER:					testChunk(subChunk);				case ANIM_OBJ:					parseAnimation(subChunk);				default:					skipChunk(subChunk);			}						chunk.bytesRead += subChunk.length;		}	}		private function testChunk(chunk:Chunk3ds):Void	{		max3ds.position += chunk.length - chunk.bytesRead;		chunk.bytesRead = chunk.length;	}			private function parseMaterial(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MAT_NAME:					readMaterialName(subChunk);				case MAT_AMBIENT:					readColor(AMBIENT);				case MAT_DIFFUSE:					readColor(DIFFUSE);				case MAT_SPECULAR:					readColor(SPECULAR);				case MAT_TEXMAP:					parseMaterial(subChunk);				case MAT_TEXFLNM:					readTextureFileName(subChunk);				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		private function parseAnimation(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length) {			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id) {				case ANIM_NAME:					readAnimationName(subChunk);				case ANIM_PIVOT:					readPivot(subChunk);				/*				case ANIM_POS:					readPosTrack(subChunk);				case ANIM_ROT:					readRotTrack(subChunk);				case ANIM_SCALE:					readScaleTrack(subChunk);				*/				default:					skipChunk(subChunk);			}						chunk.bytesRead += subChunk.length;		}	}		private function readAnimationName(chunk:Chunk3ds):Void	{		_meshData = Lib.as(_meshDictionary.get(readASCIIZString(max3ds)), MeshData);		chunk.bytesRead += _meshData.name.length + 1;				var flags1 = max3ds.readUnsignedShort();		flags1;		chunk.bytesRead += 2;				var flags2 = max3ds.readUnsignedShort();		flags2;		chunk.bytesRead += 2;				var heirarchy = max3ds.readUnsignedShort();		heirarchy;		chunk.bytesRead += 2;	}		private function readPivot(chunk:Chunk3ds):Void	{		var x:Float = max3ds.readFloat();		var y:Float = max3ds.readFloat();		var z:Float = max3ds.readFloat();		_meshData.transform.appendTranslation(-z, y, -x);		chunk.bytesRead = chunk.length;	}	/*	private function readPosTrack(chunk:Chunk3ds):void	{		max3ds.position += 10;				var numFrames:uint = max3ds.readUnsignedShort();				max3ds.position += 2;				for (var i:int = 0; i < numFrames; ++i)		{			max3ds.readUnsignedShort();			max3ds.readUnsignedInt();			var x:Float = max3ds.readFloat();			var y:Float = max3ds.readFloat();			var z:Float = max3ds.readFloat();			_meshData.transform.appendTranslation(-z, y, -x);		}				chunk.bytesRead = chunk.length;	}		private function readRotTrack(chunk:Chunk3ds):void	{		max3ds.position += 10;				var numFrames:uint = max3ds.readUnsignedShort();				max3ds.position += 2;				for (var i:int = 0; i < numFrames; ++i)		{			max3ds.readUnsignedShort();			max3ds.readUnsignedInt();			var rot:Float = max3ds.readFloat()*180/Math.PI;			var x:Float = max3ds.readFloat();			var y:Float = max3ds.readFloat();			var z:Float = max3ds.readFloat();			_meshData.transform.prependRotation(rot, new Vector3D(-z, y, -x));		}				chunk.bytesRead = chunk.length;	}		private function readScaleTrack(chunk:Chunk3ds):void	{		max3ds.position += 10;				var numFrames:uint = max3ds.readUnsignedShort();				max3ds.position += 2;				for (var i:int = 0; i < numFrames; ++i)		{			max3ds.readUnsignedShort();			max3ds.readUnsignedInt();			var x:Float = max3ds.readFloat();			var y:Float = max3ds.readFloat();			var z:Float = max3ds.readFloat();			_meshData.transform.prependScale(-z, y, -x);		}				chunk.bytesRead = chunk.length;	}	*/		private function readMaterialName(chunk:Chunk3ds):Void	{		_materialData = _materialLibrary.addMaterial(readASCIIZString(max3ds));				Debug.trace(" + Build Material : " + _materialData.name);				chunk.bytesRead = chunk.length;	}		private function readColor(type:String):Void	{		if (shading)			_materialData.materialType = MaterialData.SHADING_MATERIAL;		else			_materialData.materialType = MaterialData.COLOR_MATERIAL;				var color:Int = 0;		var chunk:Chunk3ds = new Chunk3ds();		readChunk(chunk);		switch (chunk.id)		{			case COLOR_RGB:				color = readColorRGB(chunk);			case COLOR_F:			// TODO: write implentation code				Debug.trace("COLOR_F not implemented yet");				skipChunk(chunk);			default:				skipChunk(chunk);				Debug.trace("unknown ambient color format");		}				switch (type)		{			case AMBIENT:				_materialData.ambientColor = color;			case DIFFUSE:				_materialData.diffuseColor = color;			case SPECULAR:				_materialData.specularColor = color;		}	}		private function readColorRGB(chunk:Chunk3ds):Int	{		var color:Int = 0;				var i = -1;		while (++i < 3)		{			var c:Int = max3ds.readUnsignedByte();			color += Std.int(c*Math.pow(0x100, 2-i));			chunk.bytesRead++;		}				return color;	}		private function readTextureFileName(chunk:Chunk3ds):Void	{		_materialData.textureFileName = readASCIIZString(max3ds);		_materialData.materialType = MaterialData.TEXTURE_MATERIAL;				chunk.bytesRead = chunk.length;	}		private function parseMesh(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MESH_OBJECT:					parseMesh(subChunk);				case MESH_VERTICES:					readMeshVertices(subChunk);				case MESH_FACES:					readMeshFaces(subChunk);					parseMesh(subChunk);				case MESH_MATER:					readMeshMaterial(subChunk);				case MESH_TEX_VERT:					readMeshTexVert(subChunk);				/*				case MESH_XFMATRIX:					readMeshMatrix(subChunk);				*/				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		private function readMeshName(chunk:Chunk3ds):Void	{		_meshDictionary.set(_meshData.name = readASCIIZString(max3ds), _meshData);		chunk.bytesRead += _meshData.name.length + 1;				Debug.trace(" + Build Mesh : " + _meshData.name);	}		private function readMeshVertices(chunk:Chunk3ds):Void	{		var numVerts:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;				var i = -1;		while (++i < numVerts)		{			_meshData.geometry.vertices.push3(max3ds.readFloat()*scaling, -max3ds.readFloat()*scaling, -max3ds.readFloat()*scaling);			chunk.bytesRead += 12;		}	}		private function readMeshFaces(chunk:Chunk3ds):Void	{		var numFaces:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;		var i = -1;		while (++i < numFaces)		{			_geometryData.indices.push3(max3ds.readUnsignedShort(), max3ds.readUnsignedShort(), max3ds.readUnsignedShort());			_geometryData.faceLengths.push(3);			max3ds.readUnsignedShort();			chunk.bytesRead += 8;						_geometryData.faces.push(new FaceData());		}	}			/**	 * Read the Mesh Material chunk	 * 	 * @param chunk	 * 	 */	private function readMeshMaterial(chunk:Chunk3ds):Void	{		var meshMaterial:MeshMaterialData = new MeshMaterialData();		meshMaterial.symbol = readASCIIZString(max3ds);		chunk.bytesRead += meshMaterial.symbol.length +1;				var numFaces:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;		var i = -1;		while (++i < numFaces)		{			meshMaterial.faceList.push(max3ds.readUnsignedShort());			chunk.bytesRead += 2;		}				_meshData.geometry.materials.push(meshMaterial);	}		private function readMeshTexVert(chunk:Chunk3ds):Void	{		var numUVs:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;				var i = -1;		while (++i < numUVs)		{			_meshData.geometry.uvtData.push3(max3ds.readFloat(), 1-max3ds.readFloat(), 0);			chunk.bytesRead += 8;		}	}		/**	 * Reads a null-terminated ascii string out of a byte array.	 * 	 * @param data The byte array to read from.	 * @return The string read, without the null-terminating character.	 * 	 */			private function readASCIIZString(data:ByteArray):String	{		//var readLength:Int = 0; // length of string to read		var l:Int = data.length - data.position;		var tempByteArray:ByteArray = new ByteArray();				var i = -1;		while (++i < l)		{			var c:Int = data.readByte();						if (c == 0)			{				break;			}			tempByteArray.writeByte(c);		}				var asciiz:String = "";		tempByteArray.position = 0;		i = -1;		var len:Int = tempByteArray.length;		while (++i < len)		{			asciiz += String.fromCharCode(tempByteArray.readByte());		}		return asciiz;	}		private function buildMeshes():Void	{				for (_meshData in meshDataList)		{			//create Mesh object			var mesh:Mesh = new Mesh();			mesh.name = _meshData.name;			mesh.transform.matrix3D = _meshData.transform;						_geometryData = _meshData.geometry;						//set materialdata for each face			for (_meshMaterialData in _geometryData.materials) {				for (_faceListIndex in _meshMaterialData.faceList) {					var _faceData:FaceData = Lib.as(_geometryData.faces[_faceListIndex], FaceData);					_faceData.materialData = materialLibrary.get(_meshMaterialData.symbol);				}			}						for (_faceData in _geometryData.faces) {				//set face materials				_materialData = _faceData.materialData;				mesh.arcaneNS()._faceMaterials.push(_materialData.material);			}						//store mesh material reference for later setting by the materialLibrary			if (_materialData != null)				_materialData.meshes.push(mesh);						mesh.arcaneNS()._vertices = _geometryData.vertices;			mesh.arcaneNS()._uvtData = _geometryData.uvtData;			mesh.arcaneNS()._indices = _geometryData.indices;			mesh.arcaneNS()._faceLengths = _geometryData.faceLengths;						mesh.arcaneNS().buildFaces();						//store element material reference for later setting by the materialLibrary			for (_face in mesh.arcaneNS()._faces)				if ((_materialData = _geometryData.faces[_face.faceIndex].materialData) != null)					_materialData.faces.push(_face);						//center vertex points in mesh for better bounding radius calulations			if (centerMeshes) {				var i:Int = Std.int(mesh.arcaneNS()._vertices.length/3);				_moveVector.x = (_geometryData.maxX + _geometryData.minX)/2;				_moveVector.y = (_geometryData.maxY + _geometryData.minY)/2;				_moveVector.z = (_geometryData.maxZ + _geometryData.minZ)/2;				while (i-- > 0) {					mesh.arcaneNS()._vertices[i*3] -= _moveVector.x;					mesh.arcaneNS()._vertices[i*3+1] -= _moveVector.y;					mesh.arcaneNS()._vertices[i*3+2] -= _moveVector.z;				}				mesh.transform.matrix3D.appendTranslation(_moveVector.x, _moveVector.y, _moveVector.z);			}						mesh.type = ".3ds";			_container.downcast(ObjectContainer3D).addChild(mesh);		}	}		/**	 * Controls the use of shading materials when color textures are encountered. Defaults to false.	 */	public var shading:Bool;		/**	 * A scaling factor for all geometry in the model. Defaults to 1.	 */	public var scaling:Float;		/**	 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.	 */	public var centerMeshes:Bool;		/**	 * Creates a new <code>Max3DS</code> object. Not intended for direct use, use the static <code>parse</code> or <code>load</code> methods.	 * 	 * @param	data				The binary data of a loaded file.	 * @param	init	[optional]	An initialisation object for specifying default instance properties.	 * 	 * @see away3dlite.loaders.Max3DS#parse()	 * @see away3dlite.loaders.Max3DS#load()	 */	public function new()	{		super();				_meshDictionary = new Hash<MeshData>();				_moveVector = new Vector3D();		meshDataList = [];		shading = false;		scaling = 1;				_container = new ObjectContainer3D();		_container.name = "max3ds";				_container.materialLibrary = _materialLibrary;		_container.geometryLibrary = _geometryLibrary;				binary = true;	}}class Chunk3ds{		public var id:Int;	public var length:Int;	public var bytesRead:Int;	 	public function new() { }}