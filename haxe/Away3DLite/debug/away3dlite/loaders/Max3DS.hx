package away3dlite.loaders;import away3dlite.containers.ObjectContainer3D;import away3dlite.core.base.Mesh;import away3dlite.core.utils.Cast;import away3dlite.core.utils.Debug;import away3dlite.loaders.data.GeometryData;import away3dlite.loaders.data.MaterialData;import away3dlite.loaders.data.MeshData;import away3dlite.loaders.data.MeshMaterialData;import flash.geom.Vector3D;import flash.utils.ByteArray;import flash.utils.Endian;//use namespace arcane;using away3dlite.namespace.Arcane;using away3dlite.haxeutils.HaxeUtils;/*** File loader for the 3DS file format.*/class Max3DS extends AbstractParser{	/** @private */	/*arcane*/ private override function prepareData(data:Dynamic):Void	{		max3ds = Cast.bytearray(data);		max3ds.endian = Endian.LITTLE_ENDIAN;				//first chunk is always the primary, so we simply read it and parse it		var chunk:Chunk3ds = new Chunk3ds();		readChunk(chunk);		parse3DS(chunk);				//build the meshes		buildMeshes();				//build materials		buildMaterials();	}		/** An array of bytes from the 3ds files. */	private var max3ds:ByteArray;	private var _materialData:MaterialData;	//private var _faceMaterial:ITriangleMaterial;	private var _meshData:MeshData;	private var _geometryData:GeometryData;	private var _moveVector:Vector3D;		//>----- Color Types --------------------------------------------------------		private static inline var AMBIENT:String = "ambient";	private static inline var DIFFUSE:String = "diffuse";	private static inline var SPECULAR:String = "specular";		//>----- Main Chunks --------------------------------------------------------		//private static inline var PRIMARY:Int = 0x4D4D;	private static inline var EDIT3DS:Int = 0x3D3D;  // Start of our actual objects	private static inline var KEYF3DS:Int = 0xB000;  // Start of the keyframe information		//>----- General Chunks -----------------------------------------------------		//private static inline var VERSION:Int = 0x0002;	//private static inline var MESH_VERSION:Int = 0x3D3E;	//private static inline var KFVERSION:Int = 0x0005;	private static inline var COLOR_F:Int = 0x0010;	private static inline var COLOR_RGB:Int = 0x0011;	//private static inline var LIN_COLOR_24:Int = 0x0012;	//private static inline var LIN_COLOR_F:Int = 0x0013;	//private static inline var INT_PERCENTAGE:Int = 0x0030;	//private static inline var FLOAT_PERC:Int = 0x0031;	//private static inline var MASTER_SCALE:Int = 0x0100;	//private static inline var IMAGE_FILE:Int = 0x1100;	//private static inline var AMBIENT_LIGHT:Int = 0X2100;		//>----- Object Chunks -----------------------------------------------------		private static inline var MESH:Int = 0x4000;	private static inline var MESH_OBJECT:Int = 0x4100;	private static inline var MESH_VERTICES:Int = 0x4110;	//private static inline var VERTEX_FLAGS:Int = 0x4111;	private static inline var MESH_FACES:Int = 0x4120;	private static inline var MESH_MATER:Int = 0x4130;	private static inline var MESH_TEX_VERT:Int = 0x4140;	//private static inline var MESH_XFMATRIX:Int = 0x4160;	//private static inline var MESH_COLOR_IND:Int = 0x4165;	//private static inline var MESH_TEX_INFO:Int = 0x4170;	//private static inline var HEIRARCHY:Int = 0x4F00;		//>----- Material Chunks ---------------------------------------------------		private static inline var MATERIAL:Int = 0xAFFF;	private static inline var MAT_NAME:Int = 0xA000;	private static inline var MAT_AMBIENT:Int = 0xA010;	private static inline var MAT_DIFFUSE:Int = 0xA020;	private static inline var MAT_SPECULAR:Int = 0xA030;	//private static inline var MAT_SHININESS:Int = 0xA040;	//private static inline var MAT_FALLOFF:Int = 0xA052;	//private static inline var MAT_EMISSIVE:Int = 0xA080;	//private static inline var MAT_SHADER:Int = 0xA100;	private static inline var MAT_TEXMAP:Int = 0xA200;	private static inline var MAT_TEXFLNM:Int = 0xA300;	//private static inline var OBJ_LIGHT:Int = 0x4600;	//private static inline var OBJ_CAMERA:Int = 0x4700;		//>----- KeyFrames Chunks --------------------------------------------------		//private static inline var ANIM_HEADER:Int = 0xB00A;	//private static inline var ANIM_OBJ:Int = 0xB002;	//private static inline var ANIM_NAME:Int = 0xB010;	//private static inline var ANIM_POS:Int = 0xB020;	//private static inline var ANIM_ROT:Int = 0xB021;	//private static inline var ANIM_SCALE:Int = 0xB022;		/**	 * Array of mesh data objects used for storing the parsed 3ds data structure.	 */	private var meshDataList:Array<MeshData>;		/**	 * Read id and length of 3ds chunk	 * 	 * @param chunk 	 * 	 */			private function readChunk(chunk:Chunk3ds):Void	{		chunk.id = max3ds.readUnsignedShort();		chunk.length = max3ds.readUnsignedInt();		chunk.bytesRead = 6;	}		/**	 * Skips past a chunk. If we don't understand the meaning of a chunk id,	 * we just skip past it.	 * 	 * @param chunk	 * 	 */			private function skipChunk(chunk:Chunk3ds):Void	{		max3ds.position += chunk.length - chunk.bytesRead;		chunk.bytesRead = chunk.length;	}		/**	 * Read the base 3DS object.	 * 	 * @param chunk	 * 	 */			private function parse3DS(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case EDIT3DS:					parseEdit3DS(subChunk);				case KEYF3DS:					skipChunk(subChunk);				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		/**	 * Read the Edit chunk	 * 	 * @param chunk	 * 	 */	private function parseEdit3DS(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MATERIAL:					parseMaterial(subChunk);				case MESH:					_meshData = new MeshData();					_meshData.material = _materialData;					readMeshName(subChunk);					_meshData.geometry = _geometryLibrary.addGeometry(_meshData.name);					_geometryData = _meshData.geometry;					parseMesh(subChunk);					meshDataList.push(_meshData);										if (centerMeshes) {												_geometryData.maxX = Math.NEGATIVE_INFINITY;						_geometryData.minX = Math.POSITIVE_INFINITY;						_geometryData.maxY = Math.NEGATIVE_INFINITY;						_geometryData.minY = Math.POSITIVE_INFINITY;						_geometryData.maxZ = Math.NEGATIVE_INFINITY;						_geometryData.minZ = Math.POSITIVE_INFINITY;						var i:Int = Std.int(_meshData.geometry.vertices.length/3);						var vertexX:Float;						var vertexY:Float;						var vertexZ:Float;						while (i-- > 0) {							vertexX = _meshData.geometry.vertices[i*3];							vertexY = _meshData.geometry.vertices[i*3+1];							vertexZ = _meshData.geometry.vertices[i*3+2];							if (_geometryData.maxX < vertexX)								_geometryData.maxX = vertexX;							if (_geometryData.minX > vertexX)								_geometryData.minX = vertexX;							if (_geometryData.maxY < vertexY)								_geometryData.maxY = vertexY;							if (_geometryData.minY > vertexY)								_geometryData.minY = vertexY;							if (_geometryData.maxZ < vertexZ)								_geometryData.maxZ = vertexZ;							if (_geometryData.minZ > vertexZ)								_geometryData.minZ = vertexZ;						}					}									default:					skipChunk(subChunk);			}						chunk.bytesRead += subChunk.length;		}	}		private function parseMaterial(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MAT_NAME:					readMaterialName(subChunk);				case MAT_AMBIENT:					readColor(AMBIENT);				case MAT_DIFFUSE:					readColor(DIFFUSE);				case MAT_SPECULAR:					readColor(SPECULAR);				case MAT_TEXMAP:					parseMaterial(subChunk);				case MAT_TEXFLNM:					readTextureFileName(subChunk);				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		private function readMaterialName(chunk:Chunk3ds):Void	{		_materialData = _materialLibrary.addMaterial(readASCIIZString(max3ds));				Debug.trace(" + Build Material : " + _materialData.name);				chunk.bytesRead = chunk.length;	}		private function readColor(type:String):Void	{		if (shading)			_materialData.materialType = MaterialData.SHADING_MATERIAL;		else			_materialData.materialType = MaterialData.COLOR_MATERIAL;				var color:Int = 0;		var chunk:Chunk3ds = new Chunk3ds();		readChunk(chunk);		switch (chunk.id)		{			case COLOR_RGB:				color = readColorRGB(chunk);			case COLOR_F:			// TODO: write implentation code				Debug.trace("COLOR_F not implemented yet");				skipChunk(chunk);			default:				skipChunk(chunk);				Debug.trace("unknown ambient color format");		}				switch (type)		{			case AMBIENT:				_materialData.ambientColor = color;			case DIFFUSE:				_materialData.diffuseColor = color;			case SPECULAR:				_materialData.specularColor = color;		}	}		private function readColorRGB(chunk:Chunk3ds):Int	{		var color:Int = 0;				var i = -1;		while (++i < 3)		{			var c:Int = max3ds.readUnsignedByte();			color += Std.int(c*Math.pow(0x100, 2-i));			chunk.bytesRead++;		}				return color;	}		private function readTextureFileName(chunk:Chunk3ds):Void	{		_materialData.textureFileName = readASCIIZString(max3ds);		_materialData.materialType = MaterialData.TEXTURE_MATERIAL;				chunk.bytesRead = chunk.length;	}		private function parseMesh(chunk:Chunk3ds):Void	{		while (chunk.bytesRead < chunk.length)		{			var subChunk:Chunk3ds = new Chunk3ds();			readChunk(subChunk);			switch (subChunk.id)			{				case MESH_OBJECT:					parseMesh(subChunk);				case MESH_VERTICES:					readMeshVertices(subChunk);				case MESH_FACES:					readMeshFaces(subChunk);					parseMesh(subChunk);				case MESH_MATER:					readMeshMaterial(subChunk);				case MESH_TEX_VERT:					readMeshTexVert(subChunk);				default:					skipChunk(subChunk);			}			chunk.bytesRead += subChunk.length;		}	}		private function readMeshName(chunk:Chunk3ds):Void	{		_meshData.name = readASCIIZString(max3ds);		chunk.bytesRead += _meshData.name.length + 1;				Debug.trace(" + Build Mesh : " + _meshData.name);	}		private function readMeshVertices(chunk:Chunk3ds):Void	{		var numVerts:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;				var i = -1;		while (++i < numVerts)		{			_meshData.geometry.vertices.xyzpush(max3ds.readFloat()*scaling, -max3ds.readFloat()*scaling, -max3ds.readFloat()*scaling);			chunk.bytesRead += 12;		}	}		private function readMeshFaces(chunk:Chunk3ds):Void	{		var numFaces:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;		var i = -1;		while (++i < numFaces)		{			_geometryData.indices.xyzpush(max3ds.readUnsignedShort(), max3ds.readUnsignedShort(), max3ds.readUnsignedShort());			max3ds.readUnsignedShort();			chunk.bytesRead += 8;		}	}			/**	 * Read the Mesh Material chunk	 * 	 * @param chunk	 * 	 */	private function readMeshMaterial(chunk:Chunk3ds):Void	{		var meshMaterial:MeshMaterialData = new MeshMaterialData();		meshMaterial.symbol = readASCIIZString(max3ds);		chunk.bytesRead += meshMaterial.symbol.length +1;				var numFaces:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;		var i = -1;		while (++i < numFaces)		{			meshMaterial.faceList.push(max3ds.readUnsignedShort());			chunk.bytesRead += 2;		}				_meshData.geometry.materials.push(meshMaterial);	}		private function readMeshTexVert(chunk:Chunk3ds):Void	{		var numUVs:Int = max3ds.readUnsignedShort();		chunk.bytesRead += 2;				var i = -1;		while (++i < numUVs)		{			_meshData.geometry.uvtData.xyzpush(max3ds.readFloat(), 1-max3ds.readFloat(), 0);			chunk.bytesRead += 8;		}	}		/**	 * Reads a null-terminated ascii string out of a byte array.	 * 	 * @param data The byte array to read from.	 * @return The string read, without the null-terminating character.	 * 	 */			private function readASCIIZString(data:ByteArray):String	{		//var readLength:Int = 0; // length of string to read		var l:Int = data.length - data.position;		var tempByteArray:ByteArray = new ByteArray();				var i = -1;		while (++i < l)		{			var c:Int = data.readByte();						if (c == 0)			{				break;			}			tempByteArray.writeByte(c);		}				var asciiz:String = "";		tempByteArray.position = 0;		i = -1;		var len = tempByteArray.length;		while (++i < len)		{			asciiz += String.fromCharCode(tempByteArray.readByte());		}		return asciiz;	}		private function buildMeshes():Void	{				for (_meshData in meshDataList)		{			//create Mesh object			var mesh:Mesh = new Mesh();			mesh.name = _meshData.name;			_meshData.material.meshes.push(mesh);			_geometryData = _meshData.geometry;				/*			var geometry:Geometry = _geometryData.geometry;						if (!geometry) {				geometry = _geometryData.geometry = new Geometry();								mesh.geometry = geometry;								//set materialdata for each face				for each (var _meshMaterialData:MeshMaterialData in _geometryData.materials) {					for each (var _faceListIndex:Int in _meshMaterialData.faceList) {						var _faceData:FaceData = _geometryData.faces[_faceListIndex] as FaceData;						_faceData.materialData = materialLibrary[_meshMaterialData.symbol];					}				}								for each(_faceData in _geometryData.faces) {										if (_faceData.materialData)						_faceMaterial = _faceData.materialData.material as ITriangleMaterial;					else						_faceMaterial = null;										var _face:Face = new Face(_geometryData.vertices[_faceData.v0],												_geometryData.vertices[_faceData.v1],												_geometryData.vertices[_faceData.v2],												_faceMaterial,												_geometryData.uvs[_faceData.v0],												_geometryData.uvs[_faceData.v1],												_geometryData.uvs[_faceData.v2]);					geometry.addFace(_face);										if (_faceData.materialData)						_faceData.materialData.elements.push(_face);				}			} else {				mesh.geometry = geometry;			}				*/			mesh.arcane()._vertices = _geometryData.vertices;			var uvt:Float;			for (uvt in _geometryData.uvtData)				mesh.arcane()._uvtData.push(uvt);			var index:Int;			for (index in _geometryData.indices)				mesh.arcane()._indices.push(index);						mesh.arcane().buildFaces();						//center vertex points in mesh for better bounding radius calulations			if (centerMeshes) {				var i:Int = Std.int(mesh.arcane()._vertices.length/3);				_moveVector.x = (_geometryData.maxX + _geometryData.minX)/2;				_moveVector.y = (_geometryData.maxY + _geometryData.minY)/2;				_moveVector.z = (_geometryData.maxZ + _geometryData.minZ)/2;				while (i-- > 0) {					mesh.arcane()._vertices[i*3] -= _moveVector.x;					mesh.arcane()._vertices[i*3+1] -= _moveVector.y;					mesh.arcane()._vertices[i*3+2] -= _moveVector.z;				}				_moveVector = mesh.transform.matrix3D.transformVector(_moveVector);				mesh.x += _moveVector.x;				mesh.y += _moveVector.y;				mesh.z += _moveVector.z;			}						mesh.type = ".3ds";			_container.downcast(ObjectContainer3D).addChild(mesh);		}	}		/**	 * Controls the use of shading materials when color textures are encountered. Defaults to false.	 */	public var shading:Bool;		/**	 * A scaling factor for all geometry in the model. Defaults to 1.	 */	public var scaling:Float;		/**	 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.	 */	public var centerMeshes:Bool;		/**	 * Creates a new <code>Max3DS</code> object. Not intended for direct use, use the static <code>parse</code> or <code>load</code> methods.	 * 	 * @param	data				The binary data of a loaded file.	 * @param	init	[optional]	An initialisation object for specifying default instance properties.	 * 	 * @see away3dlite.loaders.Max3DS#parse()	 * @see away3dlite.loaders.Max3DS#load()	 */	public function new()	{		super();				_moveVector = new Vector3D();		meshDataList = [];		shading = false;		scaling = 1;				_container = new ObjectContainer3D();		_container.name = "max3ds";				_container.materialLibrary = _materialLibrary;		_container.geometryLibrary = _geometryLibrary;				binary = true;	}}class Chunk3ds{		public var id:Int;	public var length:Int;	public var bytesRead:Int;	 	public function new() { }}