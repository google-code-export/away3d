package away3d.exporters{	import away3d.arcane;	import away3d.core.base.Mesh;	import away3d.core.base.Object3D;	import away3d.core.geom.Plane3D;	import away3d.graphs.TreeIterator;	import away3d.graphs.bsp.BSPNode;	import away3d.graphs.bsp.BSPTree;	import away3d.exporters.data.ExporterEvent;		import away3d.materials.ITriangleMaterial;	import away3d.materials.BitmapMaterial;	import away3d.materials.BitmapFileMaterial;	import away3d.exporters.AWDataExporterAIR;		import away3d.exporters.data.ImageData;	import flash.display.BitmapData;	use namespace arcane;		public class BSPExporterAIR extends AWDataExporterAIR	{		private var _iterator:TreeIterator;		private var _materialsList:Array;		private var _materialString:String;				public function BSPExporterAIR()		{			super();		}				/**		* Generates a string in the awd format (away3D data). Generate files represents the exported BSPTree.		* This class is suitable for runtime load of data.		* @param	object3d				Object3D. The BSPTree to be exported to the awd format (away3d data).		* @param	filename				String. The name for the to be saved .awd file.		* @param	exportmaps			[optional] Boolean. Export the texture maps or not. Default is true.		*/		public override function export(object3d:Object3D, filename:String, exportmaps:Boolean = true):void		{			reset();			addOnGenerateComplete(saveFiles);			var asString:String;			var tree:BSPTree = BSPTree(object3d);			_materialsList = [];			_numMeshes = 0; 			_filename = filename;			_exportmaps = exportmaps;						_iterator = new TreeIterator(tree._rootNode);			_iterator.performMethod(parseNode);			generateMatString();			asString = "//AWDataExporter version 1.1, Away3D Flash 10, generated by Away3D: http://www.away3d.com\n";			asString += "#v:1.1\n"			asString += "#f:2\n";			asString += "#t:bsp\n";			asString += "#d\n" + geoString;			asString += "#b\n" + _branchesString;			asString += "#l\n" + _leavesString;			asString += "#m\n" + _materialString;			asString += "\n#end of file";			 			customString = asString;			 			dispatchGenerated();						_materialsList = null; 		}		private function generateMatString():void		{			_materialString = "";			var imagedata:ImageData;			for (var i:int = 0; i < _aMats.length; ++i) {				imagedata = _aMats[i];				_materialString += "images/"+imagedata.filename+"\n";			}		}		private function parseNode(node:BSPNode):void		{			if (node._isLeaf)				parseLeaf(node);			else				parseBranch(node);		}		private function parseBranch(node:BSPNode):void		{			var plane:Plane3D;			var bevels:Vector.<Plane3D> = node._bevelPlanes;			var len:int;			var pos:BSPNode = node._positiveNode;			var neg:BSPNode = node._negativeNode;			// save:			// - node id			// - positive node id			// - negative node id			// - partition plane			// - bevel planes			_branchesString += node.nodeId + ",";			_branchesString += (pos? pos.nodeId:"-1") + ",";			_branchesString += (neg? neg.nodeId:"-1") + ",";			plane = node._partitionPlane;			_branchesString += plane._alignment + "," +							   plane.a.toString() + "," +							   plane.b.toString() + "," +							   plane.c.toString() + "," +							   plane.d.toString() + "\n";			if (bevels && bevels.length > 0) {				len = bevels.length;				for (var i:int = 0; i < len; ++i) {					plane = bevels[i];					_branchesString += 	plane.a.toString() + "," +								   		plane.b.toString() + "," +								   		plane.c.toString() + "," +								   		plane.d.toString();					if (i < len-1) _branchesString += ",";				}			}			else {				_branchesString += "-1,-1";			}			_branchesString += "\n";		}		private function parseLeaf(node:BSPNode):void		{			var visList:Vector.<int> = node._visList;			var len:int;			var mesh:Mesh = node._mesh;			var faces:Array = mesh.geometry.faces;			var i:int;			var mat:ITriangleMaterial;			var matIndex:int;			len = faces.length;			for (i = 0; i < len; ++i) {				mat = faces[i].material;				matIndex = _materialsList.indexOf(mat);				if (matIndex == -1 && (mat is BitmapMaterial || mat is BitmapFileMaterial)) {					matIndex = _materialsList.length;					_materialsList.push(mat);					if(mat != null){						//addon to ensure unique maps are saved in right format: jpg or png if they have transparency						var bmd:BitmapData = (mat as BitmapMaterial).bitmap;						var ext:String = bmd.transparent ? ".png" : ".jpg";						_aMats.push(new ImageData(bmd, bmd.transparent, (mat as BitmapMaterial).name+ext, 100));					}				}			}			_leavesString += node.nodeId.toString() + ",";			_leavesString += node.leafId.toString() + ",";			_leavesString += (_numMeshes++) + "\n";			if (visList) {				len = visList.length;				for (i = 0; i < len; ++i) {					_leavesString += visList[i].toString(16);					if (i < len-1) _leavesString += ",";				}			}			_leavesString += "\n";						write(node._mesh, 0, _materialsList);			// save:			// - node id			// - leaf id			// - mesh (maybe we can save mesh data somewhere else, and keep leaf id?)			// - vislist		}			}}